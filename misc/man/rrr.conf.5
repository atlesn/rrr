.Dd 2021-08-21
.TH RRR.CONF 5
.SH NAME
Read Route Record is a dynamic module-based message handling program
for collecting, buffering, processing and storing messages and measurements.
.SH DESCRIPTION
The
.B rrr
environment is set up with a configuration file. The file specifies any number
of
.B instances
of different
.B modules.
The different instances either get RRR messages from other
instances, creates new messages based on some external data or send messages out. A
complete list of all available modules can be found in the MODULES section.
.PP
RRR messages may contain RRR array data, timestamp, topic and raw data.
.PP
All the different modules can read messages from each other, except from
.B source
modules which only receives data form external sources.
.PP
Custom functionallity may be achieved by using using the Perl or Python module to
run scripts inside of an RRR environment. It is also possible to write custom C or
C++ modules.
.PP
Once started,
.B rrr
keeps running until it is signalled to stop.
.PP
.SH SYNTAX
Any number of instances may be specified. An instance specification begins with a [] containing
the user chosen name of the instance, like
.B [INSTANCE NAME].
A module to use must then be specified with
.B module=MODULE NAME
. The
.B senders=SENDERS
settings is set if the instance is to read from other instances. After this, any module-specific parameters follows.
The order of parameters inside an instance specification and the order of the instances inside the configuration file
do not matter. An instance section ends when a new begins or when we reach the end of the file.
.PP
Multiple instances of a module may co-exist as long as their settings don't collide, like if they try to use the same
network ports.
.PP
.nf
# Comment are like this, they must be on separate lines. The instance name
# and module name are the ony parameters which are always required. Spaces
# around the = are ignored as well as spaces at the end of a line.

# User chosen name of the instance
[INSTANCE_1_NAME]
# Which module to use for the instance
module=MODULE NAME

# Which other instances to read from (not for source modules)
senders=INSTANCE NAME,...

# On program startup, wait for these instances to start before starting (optional)
wait_for=WAIT FOR,...

# Enable or disable output duplication (optional). If set to yes, all readers of this instance will
# receive all messages. If set to no, the readers will compete over the messages (default mode).
duplicate=yes

# Enable or disable output buffer for this instance (optional, buffer is by default enabled).
buffer=yes

# Enable or disable backstop check (optional, backstop is by default enabled).
backstop=yes

# Drop all messages from senders which do not match the set topic (optional)
topic_filter=MQTT TOPIC FILTER

# Module-specific arguments (module-dependant)
argument1 = value1

[INSTANCE_2_NAME]
module=...

# Any number of named array trees may be specified
# Modules parsing array data may refer to these instead of having them defined inside each instance block
{ARRAY_TREE_DEFINITION_A}
be1#type,be1#one
IF ({type} == 1)
	;
ELSIF ({type} == 2)
	be2#two
	;
ELSIF ({type} > 0)
	blob{type}#x
	;
ELSE
	err
	;
sep1#separator
;
.fi
.PP
Named array tree definitions begin with {NAME} and end with a semicolon.
In all module parameters for array definitions, it is possible to instead specify {NAME} to reference a definition
from configuration file. This is useful for more complex trees which are messy to write on a single line.
Array tree definitions may be defined above or below where they are used.
See
.Xr rrr_post(1)
for array tree syntax, and in the chapters of each module below on where they can be used.
.SH RRR MESSAGES AND ARRAYS
An RRR message consists of at least a timestamp (in microseconds) and either arbitary data or
and array of values. Messages may in addition contain an MQTT topic.
.PP
Messages can either contain arbitary data or a data array.
.PP
Modules which support parsing data arrays from externally or from other modules might require a list of expected data
types to be specified in their configuration. If the total size of the input does not match the received input, parsing
of the message will fail. Some modules also generate array messages internally, and they can be created within Perl and
Python scripts. Fields from an HTTP request can be mapped into an array, and an array can be mapped into database columns.
.PP
The general syntax for an array parsing specification (without branches) is a comma separated list of types with length and item count specifications. 
.PP
.Dl type1[length1][@count1][#tag1][,type2[length2][@count2][#tag2]][,...]
.PP
The arrays are special as it is possible to have multiple values at each position. Each position has one or more values
of the exact same type and length, and may or may not have a tag (string name) identifying the particular position. Tag
names are also not unique, multiple positions may have the same tag name also with different types.
.PP
The reason for having this "2D" like structure is to group data together when receiving in such a way that it is easy
to find the different values afterwards.
.PP
Below follows a graphical representation of an array with many values. Note that there for demonstration purposes
are two values named
.B same_tag,
and that the eight byte sequence with ASCII-characters is split into two values. The string type may be of any length
enclosed by quotes "". The quotes will be removed when the value is parsed. At the second array position, there are nine
values, and at the sixth position there are two values.
.PP
.nf
+--------+-----------------+---------------------------+----------+----------+-------------+----+
| my_int |   my_integers   |                           | same_tag | same_tag | split_blob  |    |
|   1    |1|2|3|4|5|6|7|8|9| "String data without tag" |    11    |    12    | blob | abcd | CR |
+--------+-----------------+---------------------------+----------+----------+-------------+----+
.fi
.PP
An array parsing specification to produce a dataset like this (assuming the integers are 1 byte wide):
.PP
.Dl be1#my_int,be1@9#my_integers,str,be1#same_tag,be1#same_tag,blob4@2#split_blob,sep1
.PP
Refer to the
.B ARRAY DEFINITION
section of
.Xr rrr_post(1)
for the complete specification of all the types, and the specification for array trees (branching with IF-blocks).
.SS IP MESSAGES
Some messages contain IP data, for instance messages created by a module which reads from the network. The address
of the sender will be contained within the message. All modules may use IP-messages, but not all of them use the IP-data. 
.SH BUFFERS
.PP
Each instance of a source or processor module has an output buffer from which other modules read. If buffer is
disabled, a "slot" is used instead which fits a single message.
.PP
.nf
                                     3 +------------+--------+
                                     __|  INSTANCE  | Buffer |
                Duplication off     |  |     B      | / Slot |
            +------------+--------+_|  +------------+--------+
 4 messages |  INSTANCE  | Buffer |
>---------->|     A      | / Slot |_ 1 +------------+--------+
            +------------+--------+ |  |  INSTANCE  | Buffer |
                                    |__|     C      | / Slot |
                                       +------------+--------+
.fi
.PP
If an instance is specified as sender in more than one other instance, these will compete about messages from it unless
duplication is enabled. If duplication is enabled, each reader of the duplicated instance gets it's own buffer which
is filled with copies of all messages. If the buffer is disabled, all readers must make a copy of the message in the slot
after which it is deleted.
.PP
.nf
                                       +------------+--------+
                                    4 _|  INSTANCE  | Buffer |
                Duplication on       / |     B      | / Slot |
            +------------+--------+ /  +------------+--------+
 4 messages |  INSTANCE  | Buffer |-
>---------->|            +--------| 4  +------------+--------+
            |     A      | Buffer |----|  INSTANCE  | Buffer |
            +------------+--------+    |     C      | / Slot |
                                       +------------+--------+

                                       +------------+--------+
              Duplication without   4 _|  INSTANCE  | Buffer |
                    buffer           / |     B      | / Slot |
            +------------+--------+ /  +------------+--------+
 4 messages |  INSTANCE  |        |-
>---------->|            |  Slot  | 4  +------------+--------+
            |     A      |        |----|  INSTANCE  | Buffer |
            +------------+--------+    |     C      | / Slot |
                                       +------------+--------+
.fi
.PP
If buffer is disabled, the instance will block if it has a new message to write to the output while the slot is busy,
and it will proceed once a reader has picked up the message (or all readers if duplication is enabled).

Disabling buffers may reduce latency for messages, but will decrease throughout.
For very strict throughput and/or latency requirements,
experiment with using different combinations of buffer on and off as well as duplication directly in instances or separately
in intermediate
.Xr buffer(P)
instances.
If there are not thousands of messsages per second and not high bursts, buffer may be disabled for all instances to achieve the best latency possible.

The
.Xr raw(DA)
module may be used to measure performance.

.SS BUS OPERATION, CIRCULAR OPERATION AND BACKSTOP
By default, RRR has a backstop mechanism enabled which stops messages originating from an instance to be read back into the same instance.
This allows creation of a message bus and to some extent control the direction of messages in certain situations.
.PP
.nf
     BUS            NODES
+----------+   +------------+
|          |<--|  INSTANCE  |
|          |-->| httpclient |
|          |   +------------+
|          |
|          |   +------------+
| INSTANCE |<--|  INSTANCE  |
|  buffer  |-->|  python_1  |
|          |   +------------+
|          |
|          |   +------------+
|          |<--|  INSTANCE  |
|          |-->|  python_2  |
+----------+   +------------+
.fi
.PP
In the example above, the buffer instance has the other three instances set as it's senders, and the other three has the buffer
set as their only sender. This setup allows nodes to be added and removed to the bus without the need for configuring senders on
other nodes. The Python modules may then generate HTTP requests for the httpclient to perform, and httpclient generates
responses. Backstopping prevents httpclient from receiving it's own responses back to itself. The Python will however receive
HTTP requests from each other, and they must handle this in some way, possibly just ignoring them.
.PP
.nf
     BAD BUS CONFIGURATION
+------------+   +------------+
|  INSTANCE  |<--|            |
| mqttclient |-->|  INSTANCE  |
+------------+   |   python   |
                 |            |
+------------+   |            |
|  INSTANCE  |<--|            |
| httpclient |-->|            |
+------------+   +------------+
.fi
.PP
Backstopping does not work through modules with internal buffers. In the example above, the python instance is supposed to receive
requests from the mqttclient and then make HTTP requests and convert responses back to mqttclient for it to publish. When the python
instance puts the modified message in it's output buffer, both mqttclient and httpclient will receive it even though it originated
from mqttclient. The configuration can be modified to mitigate this problem, either ny using some clever topic filtering (which
may or may not be difficult to maintain) or by using a circular configuration.
.PP
.nf
   GOOD CIRCULAR CONFIGRATION
+------------+     +------------+
|  INSTANCE  |---->|            |
| mqttclient |<-+  |  INSTANCE  |
+------------+  |  |   python   |
                |  |            |
+------------+  |  |            |
|  INSTANCE  |--+  |            |
| httpclient |<----|            |
+------------+     +------------+
.fi
.PP
In the modified example, a circular configuration is used as opposed to a star configuration. When responses are generated in the
httpclient, they are only received by the mqttclient. If the HTTP response still need to be modified before mqttclient receives it,
a separate python instance may be used in between those two.
.PP
Some modules, like the buffer module, supports examining the timestamp of a message and checking this against a TTL configuration
parameter. If modules ensure that timestamps are kept intact, which they usually are, this can mitigate any erronous loops
of messages which cannot be detected by the backstop check.
.SH MODULES AND CONFIGURATION PARAMETERS
.PP
Modules have different special capabilites, denoted by the following letters. The actual implementation may
vary between modules. Many modules can despite this handle all types of messages, more or less ignoring their contents.
.PP
.Bl -tag -width -indent
.It S
Source module, can't read from other modules
.It P
Processor module, can have senders specified to read from and may also be read from other modules
.It D
Dead-end module, can only read from other modules
.It N
Network-oriented module, cannot be used as sender nor have senders specified itself.
.It A
Module supports data arrays
.It I
Module supports IP messages
.El
.PP
All modules support array and/or IP-messages, also those who do not have  
.B A
or
.B I
specified. Array- and IP-capable modules may however use or modify data from such messages.
Messages may have both IP- and Array-data simultaneously. 
.PP
The following modules are available, they are discussed in detail further down.
.PP
.Bl -tag -width -indent
.It dummy (S)
Dummy module which generates messages.

.It raw (DA)
Dumps messages, used for debugging and performance measurements.

.It ip (PAI)
Handles IP communication, UDP and TCP.

.It exploder (PA)
Splits RRR array messages into multiple messages. 

.It mangler (PA)
Converts between data types in RRR arrays. 

.It buffer (P)
Buffers messages, may be used to duplicate messages to multiple readers.

.It ipclient (PI)
Implements the RRR assured single delivery protocol on UDP for unstable connections.

.It python3 (PAI)
Processes and generates messages with custom Python3 scripts.

.It perl5 (PAI)
Processes and generates messages with custom Perl5 scripts.

.It cmodule (P)
Processes and generates messages with custom C modules.

.It socket (SA)
Creates a socket to which other programs or
.Xr rrr_post(1)
can deliver data.

.It httpserver (PAI)
Spins up an nHTTP server which can parse input data into RRR array messages and generate requests.

.It httpclient (PAI)
Sends records and requests to an HTTP server.

.It incrementer (PA)
Keeps track of unique IDs and appends them to topics of messages.

.It cacher (PA)
Intermediate message on disk storage for continuity across restarts.

.It msgdb (N)
Filesystem storage engine for RRR messages (message DB).

.It mqttbroker (N)
A TLS-capable V5/V3.1(.1) MQTT broker supporting TLS, authentication, ACL.

.It mqttclient (PA)
Subscribes to MQTT topics and/or publishes messages. TLS-capable V5/V3.1(.1) MQTT client.

.It journal (SA)
Traps log messages from all modules and saves them into RRR messages.

.It file (SA)
Reads from files, sockets, character devices and FIFO pipes.

.It mysql (DAI)
Saves records to a MySQL or MariaDB table.

.It influxdb (DA)
Saves data to an InfluxDB database.

.It voltmonitor (SA)
Reads from a USB voltmeter.

.It averager (PA)
Collects point measurements and calculates average values.
.El
.SS dummy (S)
This module constantly generates empty messages, optionally containing some dummy data.
.PP
The following configuration parameters are available in the
.B dummy
module:
.PP
.Bl -tag -width -indent
.It dummy_no_generation={yes|no}
No messages are generated, defaults to yes.

.It dummy_no_sleeping={yes|no}
Don't sleep between creating messages, but create as many messages as the reader can handle, limited by automatic ratelimiting. Defaults to no.

.It dummy_no_ratelimit={yes|no}
If set to yes, automatic ratelimiting will be disabled even if
.B dummy_no_sleeping
is set to yes. Defaults to no.

.It dummy_sleep_interval_us=MICROSECONDS
The interval to sleep between each generated message. Cannot be set to 0, defaults to 50000 (50 ms). The sleep time is an approximate value. This parameter is ignored if
.B dummy_no_sleeping
is set to yes.

.It dummy_max_generated={unsigned number}
Stop generating messages after this number is reached. 0 value or not defined means that generation will never stop.

.It dummy_random_payload_max_size={BYTES}
When generating messages, give them an empty payload with a random size in the range 0 to BYTES. Default is 0 (no payload for messages).
Cannot be set together with
.B dummy_array_tag.

.It dummy_topic={TOPIC}
Set an MQTT topic in generated messages.

.It dummy_array_tag={TAG}
If set, array messages will be created containing a single value of type vain with the specifed tag.
Cannot be set together with
.B dummy_random_payload_max_size.
.El

.SS raw (DA)
This module reads messages from senders and drops them possibly after collection information from them.
.PP
If debuglevel 1 is active, statistics will be printed every second for performance measurement.
The statistics will show the current throughput and the average message lifetime of all messages based on their timestamp.
If per-message debugging is active, the lifetime will be printed for each message possibly along with array dumps and other information.
.PP
Debuglevel 3 will make a short summary of each message received be printed.
.PP
.Bl -tag -width -indent
.It raw_print_data={yes|no}
Print the timestamp of each received message and dump any arrays present in the messages. The global debuglevel 2 must
be set for messages to be printed.
.El
.SS ip (PAI)
This module is capable of listening on an UDP or TCP port and read messages or arrays, as well as sending data to remote hosts.
A message is created for each received packet and a timestamp is added.
If the received data does not match the specified data array, the packet is dropped.
.PP
If an instance is configured to wait for this module before starting, the we will set up any listening sockets before the
waiting instance is started.
.PP
The following configuration parameters are available in the
.B ip
module:
.PP
.Bl -tag -width -indent
.It ip_udp_port=LISTEN PORT
.It ip_tcp_port=LISTEN PORT
Port to listen on on udp or tcp. Udp  is also source port for outbound messages. Range is 1-65535, default value is 0 which means we don't listen.
If left unspecified, no listening takes place.

.It ip_input_types=ARRAY DEFINITION
Specification of expected data to receive from remote. See
.Xr rrr_post(1)
for the syntax. 
To receive RRR messages, set the definition to
.B msg
and set
.B ip_extract_rrr_messages
to
.B yes.
Array data will be read from all open connections, both for accepted connections (on the listening port) and for outgoing connections.
Array data on UDP will only be read if an UDP listening port is set.

.It ip_strip_array_separators={yes|no}
If set to yes, any array fields of the
.B sep
type is stripped out before RRR array messages are created. Defaults to no.  

.It ip_extract_rrr_messages={yes|no}
Extract any RRR messages from the received data (if specified in ip_input_types) and save them in the buffer for other modules to pick up.
Causes any other data in the received arrays to be dropped.
If set to yes and no message field is specified in the array definition, an error will be produced.
Defaults to no.

.It ip_max_message_size=BYTES
Maximum size of a message when reading. This should be set to prevent messages with missing delimeters to fill up memory.
A value of 0 means unlimited message size.
Defaults to 4096.

.It ip_default_topic=MQTT-TOPIC
An optional MQTT topic to set on the generated messages.

.It ip_sync_byte_by_byte={yes|no}
If array parsing fails according to definition, keep skipping one byte forward in the stream until a match is found.
Defaults to no, which means to only sync on boundaries of incoming messages.

.It ip_send_rrr_message={yes|no}
If set to yes, complete RRR messages encoded for network will be sent.
If set to no or left unset, messages with arrays will have their array packed and sent, and messages with other data will simply have their contents sent as is.

.It ip_preserve_order={yes|no}
Attempt to always send messages in order according to when they first arrived in the IP module.
If messages time out before they are sent, order is guaranteed for the remaining messages in the queue.
To ensure order in all situations, the parameter
.B ip_persistent_timeout_ms
should not be zero and
.B ip_send_multiple_per_connection
should be 'yes'.
Order preservation can impact performance when destinations are unreachable due to sorting.
Defaults to no which means that order is not guaranteed when there are connection problems and retries.

.It ip_send_multiple_per_connection={yes|no}
If set to no, TCP connections are forced to be closed after a single message has been sent. Defaults to 'yes'.

.It ip_persistent_connections={yes|no}
OBSOLETE, has no effect. Use ip_persistent_timeout_ms. 

.It ip_persistent_timeout_ms=MILLISECONDS
After a packet is sent or data is read on a TCP connection, keep the connection alive for the specifed amout of milliseconds or until more data is sent or received.
If set to 0, connections are closed promptly. Default value if left unset is 5000.
This parameter has no effect if
.B ip_send_multiple_per_connection
is 'no'.

.It ip_close_grace_ms=MILLISECONDS
After a TCP connection has been closed, prevent new connections to the same destination for the specified amount of milliseconds.
This prevents "ghost connections" in some situations where a host will accept a new connection immediately after another one has been closed,
even though the application on the host is not actually ready to accept any data.
May be set to zero, defaults to 5 milliseconds.

.It ip_send_timeout=SECONDS
If messages are not successfully sent within this time, perform the action specified in
.B ip_timeout_action.
Default is no timeout (same as 0).

.It ip_smart_timeout={yes|no}
If set to yes and a message is successfully sent, reset the timeout counter for all other unsent messages destined for the same host, port and protocol currently in the queue.
If set to no, unsent messages will time out according to the current send timeout regardless of whether other messages to the same destination have been sent or not in the meantime.
Defaults to no. 

.It ip_timeout_action={retry|drop|return}
What do do when a message times out after being undeliverable. In case of
.B retry,
keep trying indefinitely (default).
.B drop
will cause the message to be dropped, and
.B return
will put the message into output queue for readers to pick up. The latter is useful if an application for instance wishes to change
the destination address if the target host is unreachable, and possibly log errors. If
.B retry
is used, then
.B ip_send_timeout
must be set to zero or left undefined. 

.It ip_graylist_timeout_ms=MILLISECONDS
If a TCP destination is unreachable, add it to the graylist and retry only after the specified  number of milliseconds has passed.
Defaults to 100 ms. A value of zero disables graylisting, and causes a high rate of connection attempts to unreachable destinations.
If graylisting is used in while
.B ip_preserve_order
is also enabled, messages waiting to be sent to a graylisted host may temporarily prevent messages to other hosts from being sent.

.It ip_ttl_seconds=SECONDS
Check the creation timestamp of messages and drop them if they are or become older than the specified amount of seconds.
The TTL check is not the same as the send timeout, it does not respect
.B ip_timeout_action
nor
.B ip_smart_timeout.
TTL expiration also applies to partially sent messages.
Defaults to 0 which means that TTL check is disabled.   
 
.It ip_target_host=HOST
.It ip_target_port=PORT
.It ip_target_protocol=PROTOCOL
Default target host, port and protocol for messages from other modules which do not contain address information.
If left unset and we recevie messages which do not contain address information, the messages are dropped
and warning messages are produced. Protocol may be udp or tcp, defaults to udp.

.It ip_force_target={yes|no}
Use the specified target host and port even if messages contain other address information. Default is no.

.It ip_array_send_tags=tag1[,tag2[,...]]
Look for the defined tags in array messages from other modules, and send these concatenated together to remote.
If this option is specified and a received message is not an array or does not have all of the tags defined,
the message is dropped and an error message is produced.
If this option is left unspecified, all values from arrays are sent, and messages which are not arrays will have their raw data sent if any.
.El
.PP
.SS exploder (PA)
The exploder takes individual values from array messages and creates individual messages for each value.
.PP
.Bl -tag -width -indent
.It exploder_non_array_passthrough={yes|no}
If set to 'yes' and a non-array message is received, the message is passed through without modification.
If set to 'no' or left unset, non-array messages will be dropped.

.It exploder_original_passthrough={yes|no}
If set to 'yes', all original array messages are passed through.
If set to 'no' or left unset, the original messages are dropped.

.It exploder_preserve_timestamp={yes|no}
If set to 'yes', the timestamp from the original message will be used in any new messages.
If set to 'no' or left unset, the current time will be used for new messages.
In any case, any messages generated from a single message will have the same timestamp and the timestamp of the original message will not be modified.

.It exploder_preserve_topic={yes|no}
If set to 'yes', any topic from the original message will be used when the topics for new messages are created.
If set no 'no' or left unset, the topic will not be used.

.It exploder_topic=MQTT-TOPIC
Sets an optional static topic for new messages. If
.B exploder_preserve_topic
is 'yes', this topic specified will be appended to the original topic. No extra slashes will be added.

.It exploder_topic_append_tag={yes|no}
If set to yes, the tag of each value will be appended to topic of the generated messages.
The prefix to which the tag is added depends upon the configuration of options
.B exploder_preserve_topic
and
.B exploder_topic.
If none of those options are use, the tag will become the whole topic.
If set to 'no', the tag will not be appended to the message topic.

.El

.SS mangler (PA)
The mangler takes values from RRR arrays and converts them to different types. One RRR message with
converted values is generated for every received RRR message. Non-RRR array messages are by default
dropped.
.PP
.Bl -tag -width -indent
.It mangler_topic=MQTT-TOPIC
If set, the specified topic is set on all outgoing messages.
If left unset, any topic from the original messages is used.

.It mangler_clear_tags=TAG[,TAG...]
Values in input arrays which match one of the specified tags are deleted.
The deletion is performed prior to any conversion.
Optional parameter.

.It mangler_conversions={h2str|blob2str|blob2blob|blob2hex|str2str|str2blob|str2h|msg2blob}[,...]
A comma separated list of conversion methods which provides a conversion recipe.
For every value of input arrays, all conversions are applied from left to right.
If a conversion fails or is not possible, it is skipped and the next method is attempted.

For instance if
.B h2str,str2h
is specifed, any numeric values are converted to strings and then back again.
Should the input array contain any string values, these will fail the first conversion,
but the second conversion will convert them to to numbers. A recipe like
.B str2h
would give the same result in which case any numbers would fail to convert and would
be left as numbers in the output.

Debuglevel 4 will generate step-by-step information during conversion, and debuglevel 2 will
cause the resulting arrays to be dumped (both of these combines to debuglevel 6).

By default,
.B str
values will be quoted using double quotes when exported in modules like
.B ip (PAI)
and
.B mqttclient (PA)
to allow separation.
If strings instead are converted to blobs using
.B str2blob,
they will be exported without quotes.

Refer to the
.B CONVERSION METHODS
section for descriptions of all conversions and type compatibility.

If this parameter is not set, no conversion is performed.

.It mangler_non_array_passthrough={yes|no}
If set to 'yes', non RRR-array messages are passed through to readers. Defaults to 'no' which will cause
such messages to be dropped.

.It mangler_convert_tolerant_blobs={yes|no}
If set to 'yes', any types compatible with the
.B blob
type will be accepted in any
.B blob2*
conversions. The conversion method
.B blob2blob
will have no effect unless this parameter is used.
Defaults to 'no' which means that only values of the excact type
.B blob
are accepted.

.It mangler_convert_tolerant_strings={yes|no}
If set to 'yes', any types compatible with the
.B str
type will be accepted in any
.B str2*
conversions. The conversion method
.B str2str
will have no effect unless this parameter is used.
Defaults to 'no' which means that only values of the excact type
.B str
are accepted.
.El

.SS buffer (P)
The buffer collects all messages from all senders and wait for them to be collected by other instances.
.PP
.Bl -tag -width -indent
.It buffer_ttl_seconds=SECONDS
Any message received with timestamp older than the specified amount of seconds will be dropped. Useful in situations
where messages circulate between modules.

.It buffer_do_duplicate={yes|no}
If set to yes, incoming messages will be duplicated so that one copy is received by every reader. If set to no,
the readers will compete over the messages. Defaults to no. 
.El
.SS ipclient (PI)
The ipclient module collects any messages from senders and sends them over the network to another 
.B RRR
environment's ipclient module using UDP. It may also accept connections from other clients and receive data,
or a combination of these. An underlying UDP stream protocol ensures single delivery of
all messages (similar design as MQTT QOS2), and messages are checksummed with a CRC32 algorithm.
.PP
.B ipclient is not secure in any way and must only be used on closed networks!
.PP
After an ipclient instance has connected to a remote ipclient, the remote will accept packets, and the connection
persists even if the connecting clients IP-address changes unless specified otherwise in the configuration.
.PP
Please note that ipclient is not designed to receive connections and packets from arbitary remote hosts.
If a remote sends packets and does not complete the acknowledgement handshakes, the packets will persist in memory.
.PP
If a remote host becomes unavailable for a longer period of time, unfinished acknowledgement handshakes
are re-initiated when it becomes available again, even if it has been re-started in the mean time.
.PP
ipclient will not accept incoming connections from other clients unless explicitly told to in the configuration file.
.PP
The following configuraton parameters are available in the
.B ipclient
module:
.PP
.Bl -tag -width -indent
.It ipclient_client_number=NUMBER
Each ipclient instance in a set of instances which communicate together must have a unique ID number in the range 1-4294967295.
If you have two instances running, set one of them to 1 and the other one to 2.

.It ipclient_default_remote=REMOTE NAME OR ADDRESS
The name or address of the client which we send packets without address information to.

.It ipclient_default_remote_port=PORT NUMBER
The port number of the default remote, defaults to 5555.

.It ipclient_src_port=PORT NUMBER
Source port used for sending and receiving packtes, defaults to 5555.

.It ipclient_listen={yes|no}
Accept incoming connections if set to yes. Default is no.

.It ipclient_ipv4_only={yes|no}
If set to yes, start IPv4 networking only. If left unset or set to no, IPv6 will be attempted first, and IPv4
will only be attemted if IPv6 fails.
If IPv6 succeeds, both IPv4 and IPv6 might actually be active depending on the operating system.

.It ipclient_disallow_remote_ip_swap={yes|no}
If yes and a remote changes its IP-address, RRR must restart before the new address can be accepted. Default is no. 
.El
.SS python3 (PAI)
This module can send messages to a custom python program and read them back.
All messages read from the senders are sent to the python program to the process function specified.
A read-only source function may also be specified if the python program should only generate messages by itself and not receive any.
It is possible to specify both source- and process-functions at the same time.
Functions should return 0 on success and put any messages into the result class provided in the argument.
If something goes wrong, the functions can return 1 or raise an exception which makes RRR stop all running instances and restart.
.PP
The RRR module should be imported by the custom python program, but is in only available when the python script is called from RRR.
.PP
The following configuration parameters are available in the
.B python3
module:
.PP
.Bl -tag -width -indent
.It python3_module=MODULE NAME
The module name for the python3 program to be executed. Imported by 'from MODULE NAME import *'

.It python3_module_path=MODULE NAME
An extra path in which to search for the module.

.It python3_source_function=FUNCTION NAME
The name of the source function in the python program which we read from continously.

.It python3_process_function=FUNCTION NAME
The name of the processing function in the python program which we send packets from other modules to. We also read any messages sent back.

.It python3_config_function=FUNCTION NAME
The name of the function in the python program to which we send settings form the configuration file.
All settings defined inside the python block in the configuration file are sent in here.

.It CUSTOM SETTING=VALUE
Any number of custom settings for the python program might be set as needed.
.El
.PP
Refer to the
.B cmodule
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of the following parameters:
.PP
.Bl -tag -width -indent
.It python3_workers=UNSIGNED INTEGER
.It python3_source_interval_ms=MILLISECONDS
.It python3_sleep_time_ms=MILLISECONDS
.It python3_nothing_happend_limit=UNSIGNED INTEGER
.It python3_log_prefix=PREFIX
.It python3_drop_on_error={yes|no}
.El
.PP
Below follows an example python message processing and generating program. A socket is used to
post messages. The process and source functions have their own environments, and they will not
share any global variables set by the config function. The config function is called first in
the process environment, then in the source environment.
.PP
.nf
from rrr_helper import *
import time

my_global_variable = ""

def config(rrr_config : config):
	global my_global_variable

	# retrieve a custom setting from the configuration file. The get()
	# will update the "was-used" flag in the setting which stops a
	# warning from being printed.
	print ("Received configuration parameters")
	my_global_variable = config.get("my_global_variable")

	return True

def process(socket : rrr_socket, message: rrr_message):
	# Return False if something is wrong
	if my_global_variable == "":
		print("Error: configuration failure")
		return False
		
	# modify the retrieved message as needed
	message.timestamp = message.timestamp + 1
	
	# queue the message to be sent back (optional) for python to give to readers
	socket.send(message)
	
	return True

def source(socket : rrr_socket, message : rrr_message):
	# Set an array value in the template message
    my_array_value = rrr_array_value()
    my_array_value.set_tag("my_tag")
    my_array_value.set(0, "my_value")

    my_array = rrr_array()
    my_array.append(my_array_value)

    message.set_array(my_array)

	# queue the message to be sent back (optional) for python to give to readers
	# skip this step if the message are not to be sent, it is then simply discarded
	# may be called multiple times with the same message
	socket.send(message)
	
	# sleep to limit output rate
	time.sleep(1)

	return True
	
.fi
More details about Python in 
.Xr rrr_python3(5)
.PP
.SS perl5 (PAI)
The perl5 module makes it possible to process and generate messages in a custom 
perl script. The first and only argument to the source- and generate-functions
is the RRR message in the form of an object/hash reference of type
.B rrr_message
with different parameters which may be modified as needed. To pass the message back to RRR, the
.B $message->send()
is called. If the message should not be passed on, simply skip
the call to this method. The method may be called multiple times if required.
.PP
It is not possible to create new
.B rrr_message
objects from within the perl script. To send multiple messages in a single subroutine call,
the object passed in must be re-used. IP-, array- and data information in the message may be
cleared as needed when the message object is re-used.
.PP
It is possible to work with RRR array messages in the Perl script. This is done
through calling dedicated functions on the
.B rrr_message
object received by source and process functions. The functions available are listed in the example scripts with comments.
More details about types are found in 
.Xr rrr_post(1)
.PP
The following configuration parameters are available in the
.B perl5
module:
.PP
.Bl -tag -width -indent
.It perl5_file=FILENAME
Path and filename of the perl script to use. The script is run once when the program starts,
which means that code may be added outside the three subroutines mentioned below.

.It perl5_source_interval_ms=MILLISECONDS
How long to wait between each call of the source subroutine (if defined). Defaults to 1000 ms.

.It perl5_source_sub=SUBROUTINE NAME
Optional name of a subroutine which receives an rrr::rrr_helper::rrr_message object and modifies
it to generate a new message. Called at specified interval.

.It perl5_process_sub=SUBROUTINE NAME
Optional name of a subroutine which receives an rrr::rrr_helper::rrr_message object from the senders
of the current instance. The message may be modified or left alone.

.It perl5_config_sub=SUBROUTINE NAME
Optional name of a subroutine which receives an rrr::rrr_helper::rrr_settings object when the program
is started. Any settings from the instance definition in the configuration file can be read from
this object, also custom settings. Settings may also be modified and new settings can be added. The
settings object may also be stored in the script to be read from or modified from the source- and 
generate-subroutines.

.It CUSTOM SETTING=VALUE
Any number of custom settings for the Perl script might be set as needed.
.El
.PP
Refer to the
.B cmodule
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of the following parameters:
.PP
.Bl -tag -width -indent
.It perl5_workers=UNSIGNED INTEGER
.It perl5_source_interval_ms=MILLISECONDS
.It perl5_sleep_time_ms=MILLISECONDS
.It perl5_nothing_happend_limit=UNSIGNED INTEGER
.It perl5_log_prefix=PREFIX
.It perl5_drop_on_error={yes|no}
.El
.PP
.B NOTE:
Any modified settings will currently not be visible in the perl5 RRR module, only in the perl5 script.
.PP
There must always be either a source- or process subroutine specified, or both. If a process subroutine
is specified, there must also be at least one sender specified.
.PP
If a Perl instance receives messages from an IP-capable module, like
.B ip or httpserver,
the address information of the original sender of a message is accessible in the
.B rrr_message
object. Other IP-capable modules may
then use this information if they read data from the Perl instance, for example if you wish to use
a Perl script to generate a reply message to some remote host. There is no high-level method for modifying
the address information inside the Perl script, but the values
.B $message->{'ip_addr'}
and
.B $message->{'ip_addr_len'}
are to be found in the message hash. The values are filled with data from
.B struct sockaddr
and
.B socklen_t
which is provided by the operating system. These two values may be saved and re-used in later messages,
or they may be modified if you know how to do that (not documented here).
In addition,
.B $message->{'ip_so_type'}
can be either "udp" or "tcp" to describe a protocol type. Some modules may use this parameter. It can also be empty.
.PP
The IP information in a message can be accessed and modified through helper functions. IPv4 and IPv6 both work
with these transparently.
.PP
.Bl -tag -width -indent
.It my ($ip, $port) = $message->ip_get();
Get IP (as text) and port from the message. Returns undefined if there is no IP information in the message.

.It $message->ip_set($ip, $port);
Set IP and port in a message. The $ip is in string representation (like 2a0a::1 or 4.4.4.4). Returns 1 on success and 0 on failure.

.It $message->ip_clear();
Delete IP information from a message. Always returns 1.
.El
.PP
The following additional parameters are available in the
.B rrr_message
object:
.PP
.Bl -tag -width -indent
.It $message->{'topic'}
The MQTT topic of the messsage.

.It $message->{'timestamp'}
The timestamp of the message.

.It $message->{'data'}
The raw data of the message (ignored when array is being used). Updates to the message array will not affect this field, but data
will be cleared if the message is sent with array fields set.

.It $message->{'data_length'}
The length of the data.

.It $message->{'type_and_class'}
Type and class of message, for internal use.
.El
.PP
If the
.B rrr_message
object contains an array, helper functions must be used to access these. A non-array message will
be treated as an array message if fields are added to it, and any data set in the message will be ignored when the message is sent.
.PP
The following functions are available for array field manipulation:
.PP
.Bl -tag -width -indent
.It $message->clear_array()
Clears all array fields, the message becomes a non-array message.

.It $message->push_tag_blob(tag, data, size)
Pushes a blob type. Caller must ensure that the data hase the specified size or more.

.It $message->push_tag_str(tag, string)
Pushes a string type.

.It $message->push_tag_h(tag, number)
Pushes a 64-bit integer. If the given number is unsigned, it will be stored as unsigned 64-bit in the array, otherwise it will be signed 64-bit.

.It $message->push_tag_fixp(tag, fixed_pointer)
Pushes an RRR fixed pointer type. If a string is given, string notation like
.B /^(10#|16#|)-?\\d+\\.\\d+$/
is assumed.  If a double is given, it is converted directly from double to fixed point. If the value given will be stored as a 64-bit integer internally in perl, native fixed point will be assumed (this is difficult to control in a script).

.It $message->push_tag(tag, value)
Push a value or on array of values. The type will be identified automatically. Array values are passed by using a reference like 
\\@my_array. If multiple values are given in an array, the must all have equal length.

.It $message->clear_tag(tag)
Deletes all array positions with the specified tags

.It $message->set_tag_blob(tag, data, size)
.It $message->set_tag_str(tag, string)
.It $message->set_tag_h(tag, values)
.It $message->set_tag_fixp(tag, fixed_point)
Using these functions is the same as calling clear_tag(tag) and then the corresponding push_tag function.

.It $message->get_tag_all(tag)
Retrieve all values corresponding to the specified tag. Returns a list with one or more values or undefined.

.It $message->get_position(position_number)
Retrieve the value at the specified position. Returns a list with one or more values or undefined.

.It $message->count_positions()
Count the number of positions in the array.

.It $message->get_tag_names(tag)
Get all tag names from the array. Returns a list with zero or more values.
Always returns the same number of element as count_positions(). An empty string is used forositions without a tag.

.It $message->get_tag_counts(tag)
Get the value count at each position of the message. Returns a list with zero or more values.
Always returns the same number of element as count_positions().
.El
.PP
The
.B rrr_debug
object can be used to print out debug messages just like RRR does internally. Use these instead of perl print functions
if you wish to have your program output messages in a tidy controlled fashion. There are three different functions in this class:
.PP
.Bl -tag -width -indent
.It $debug->msg(level, message)
Messages to this function are always printed prefixed with the specified loglevel (a number 0, 1, 2 etc.).

.It $debug->dbg(level, message)
Messages to this function are printed only if the specified loglevel (debuglevel) is active. If loglevel is 0 however,
the message is always printed.

.It $debug->err(message)
Messages to this function are always printed with loglevel 0 and to STDERR output. Do not overuse this as it might
cause broadcast messages on the system when RRR is run for instance by systemd. Error messages should usually be
printed using the
.B msg
function with loglevel 0.
.El
.PP
A variable must be blessed with the
.B rrr_debug
class to use the debug functions, look at the code below on how to do this. There are also commented out example
calls to message print functions. 
.PP
Below follows an example perl script.
.PP
.nf
#!/usr/bin/perl -w

package main;

use rrr::rrr_helper;
use rrr::rrr_helper::rrr_message;
use rrr::rrr_helper::rrr_settings;
use rrr::rrr_helper::rrr_debug;

my $debug = { };
bless $debug, rrr::rrr_helper::rrr_debug;

my $global_settings = undef;

sub config {
	# Get the rrr_settings-object. Has get(key) and set(key,value) methods.
	my $settings = shift;

	# If needed, save the settings object
	$global_settings = $settings;

	# Custom settings from the configuration file must be read to avoid warning messages
	# $debug->msg(1, "my_custom_setting is: " . $settings->get("my_custom_setting") . "\\n");

	# Set a custom setting
	$settings->set("my_new_setting", "5");

	# Return 1 for success and 0 for error
	return 1;
}

sub source {
	# Receive a newly generated template message
	my $message = shift;

	# Do some modifications
	$message->{'timestamp'} = $message->{'timestamp'} - $global_settings->get("my_custom_setting");

	# $debug->msg(1, "source:  new timestamp of message is: " . $message->{'timestamp'} . "\\n");

	# Pass on the new message
	$message->send();

	# Return 1 for success and 0 for error
	return 1;
}

sub process {
	# Get a message from senders of the perl5 instance
	my $message = shift;

	# Do some modifications to the message
	$message->{'timestamp'} = $message->{'timestamp'} - $global_settings->get("my_custom_setting");

	# $debug->msg(1, "process: new timestamp of message is: " . $message->{'timestamp'} . "\\n");

	# NOTE ! To understand how message arrays work, look in the MESSAGES section in the
	# man page of rrr.conf for a graphical representation (furter up if you're already in the man page).

	# An RRR array consits of several positions which each may have one or more value of a certiain
	# type and length. A position may or may not have an identification tag, and several positions
	# may have the same tag. An RRR message either contains raw data of some sort or an RRR array.

	# If array values are pushed to the message in a Perl5 script, any data in the message
	# will not be forwarded.

	# Push some values of dirrent types onto the message array. Since
	# we use the same tag name "tag" for many values, multiple values
	# with the same tag will exist within the array.
	$message->push_tag_blob ("tag", "blob", 4);
	$message->push_tag_str ("tag", "str");
	$message->push_tag_h ("tag", 666);
	$message->push_tag_fixp ("tag", 666);

	# Set some integer values
	my @my_integers = (1, 2, 3, 4);

	# The following function will accept both array values and other values.
	# If an array reference is passed, like here, the values will be added
	# to the same tag. If they are strings, their length -must- be equal.

	# If different length strings are required, push them into separate
	# tags like above. The RRR type is chosen based on the first value
	# in the array, type h (host endian integer) will be chosen here.
	$message->push_tag ("tag", \@my_integers);

	# This will get all matching values for a particular tag. Regardless
	# of wether duplicate tags have more than one element in the or not,
	# they will all be put into the same result array. Here, all the values
	# added above (four added one by one and four from the array) will
	# be put into @values_result which will end up having eight elements.
	my @values_result = $message->get_tag ("tag");

	# The set_* functions will delete all matching tag names from the array
	# and then push the new value. The type of any existing does not matter,
	# all tags with matching tag name in the array will be removed.
	$message->set_tag_blob ("tag", "blob", 4);
	$message->set_tag_str ("tag", "str");
	$message->set_tag_fixp ("tag", 666);
	$message->set_tag_h ("tag", 1);

	# It is allowed to have empty tag names, just use "" as tag
	$message->set_tag_h("", 0);

	# Since set_tag_h is the last value, the number '1' is the only
	# element in the array now with the tag "tag". The get_tag_all
	# function will otherwise retrieve all values at all matching tags.
	my @array_with_only_one_value = $message->get_tag_all ("tag");

	# It is possible to retrieve a particular element at a certain position
	# if the position of a value is known. Since we know there is a
	# number with the tag "tag" in the array, we can get the first element
	# returned.
	my $value = ($message->get_tag_all("tag"))[0];

	# These two functions returns arrays containing the tag names
	# at each array position, or the value count at each position. If
	# there is no tag name at a position, an empty "" value is returned.
	# All array position always has at least one element.
	print "Tag names: " . join(",", $message->get_tag_names ()) . "\n";
	print "Tag counts: " . join(",", $message->get_tag_counts ()) . "\n";

	# Get all values at a particular position
	print "Get a position: " . join (",", $message->get_position(0)) . "\n";
	print "Array position count: " . $message->count_positions() . "\n";

	# This will clear all values from the array which has the specified tag
	$message->clear_tag("tag");

	# This will clear all values from the array
	# $message->clear_array();

	# Pass on the modified message
	$message->send();

	# Return 1 for success and 0 for error
	return 1;
}
.fi
.SS cmodule (P)
This module allows usage of custom cmodules (C-modules) in a simplified framework. To use this, a module must first be
written in the RRR source in the directory /src/cmodules/ and then compiled (just compile RRR as usual and
directions will be given). There is an example file with appropriate licenses in the cmodules directory
which may be used as a template for custom cmodules.
.PP
RRR will deal with communication with other modules and many other tasks, which makes it simpler to write a
cmodule than to write a native RRR module.
.PP
All custom cmodules will be run in separate forks.
.PP
The following confgiuration parameters are available in the
.B cmodule
module: 
.PP
.Bl -tag -width -indent
.It cmodule_name=NAME
The name of the cmodule. If the name is
.B dummy,
RRR will look for the module
.B dummy.so
and the source file for this module should be called
.B dummy.c.

.It cmodule_config_function=NAME
The function to which to pass configuration parameters, called at program startup. Optional.

.It cmodule_source_function=NAME
The function to which to call to source new messages. Optional, but at least one of source and processor must be set.

.It cmodule_process_function=NAME
The function to which to call to process messages from senders. Optional, but at least one of source and processor must be set.

.It cmodule_cleanup_function=NAME
The function to call before the program shuts down. Optional.

.It CUSTOM SETTING=VALUE
Any number of custom settings for the C-module might be set as needed.
.El
.PP
Refer to the
.B cmodule
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of the following parameters:
.PP
.Bl -tag -width -indent
.It cmodule_workers=UNSIGNED INTEGER
.It cmodule_source_interval_ms=MILLISECONDS
.It cmodule_sleep_time_ms=MILLISECONDS
.It cmodule_nothing_happend_limit=UNSIGNED INTEGER
.It cmodule_log_prefix=PREFIX
.It cmodule_drop_on_error={yes|no}
.El
.PP
The source and process functions receives a new message which of they must manage the memory. The message must
either be passed on to other modules by calling
.B rrr_send_and_free(...)
or be freed (if the message is to be discarded) by calling
.B rrr_free(...).
A message, if it must be sent several times, may be duplicated by using.
.B rrr_message_duplicate(...).
.PP
Please refer to the source code on how these functions work. Some headers which
might be useful when working with for instance array messages are included in /src/cmodules/cmodule.h .
It is not a priority at this time to document these, but they are easy to use and usage examples are to
be found throughout the RRR source code (which is human- and machine readable).
.PP
Functions must return 0 on success and 1 if there are errors.  
.SS socket (SA)
The socket module listens on a UNIX socket for RRR messages or custom data records.
.PP
The following configuration parameters are available in the
.B socket
module:
.PP
.Bl -tag -width -indent
.It socket_path=FILENAME
Path and file name to use for the socket. The file cannot exist when the program starts.

.It socket_unlink_if_exists={yes|no}
If set to yes and the socket defined in `socket_path` exists when we start, unlink it. If set to no, we produce an error if
the socket exists. Defaults to no.

.It socket_default_topic=MQTT-TOPIC
An optional MQTT topic to set on the generated messages.

.It socket_receive_rrr_message={yes|no}
If set to 
.B yes
, complete RRR messages are expected to be received on the socket. No array definition is to be specified. 
.Xr rrr_post(1)
may generate such messages. If set to 
.B no
, an array definition must be specified, and RRR array messages will be produced from the received data. Defaults to no.

.It socket_input_types=ARRAY DEFINITION
Format of data received on the socket, see
.Xr rrr_post(1)
for syntax.

.It socket_sync_byte_by_byte={yes|no}
If array parsing fails according to definition, keep skipping one byte forward in the stream until a match is found.
Defaults to no, which means to only sync on boundaries of incoming messages.
.El
.SS httpserver (PAI)
This module accepts connections from HTTP clients, extracts PUT. POST or GET data fields and puts it into RRR array messages
for other modules to use. The query string from the URI is parsed in both PUT, GET and POST requests. Duplicate field names are allowed.

For PUT and POST request which have a body, the following content types is parsed and fields will be extracted implicitly:

.Bl -dash -offset indent -compact
.It
multipart/form-data
.It
application/x-www-form-urlencoded
.It
application/json
.El

If other formats is to be parsed,
.B http_server_receive_full_request
can be used and the body can then be parsed by a script in the python3 or perl5 modules.

Structural fields set due to
.B http_server_receive_full_request
, fields from the URI and field from PUT/POST data will all be added to the same array in a pre-defined order.
Duplicate value names are thus allowed.

.Bl -enum -offset indent -compact
.It
Structural fields
.It
Fields from request URI
.It
Fields from PUT/POST data
.El

When receiving JSON data, one RRR array message will be generated for every JSON object containing bare associative values regardless of nesting.
In each of the messages, an additional value named
.B http_request_partials
describing the total number of messages for this request is placed at the beginning of the array followed by the structural fields and any fields from the URI before fields from the JSON object.

.PP
.B DO NOT USE
this HTTP server openly on the Internet. It has
.B NO PROTECTION MECHANISMS
against DoS attacks, flooding etc. There is also
.B NO AUTHENTICATION.
Use a server like Apache to run a public server.
.PP
This module does not respond with any data by default.
If a request was successfully processed, a
.B 204 No Content
response is returned to the client. If there was any errors,
.B 400 Bad Request
or
.B 500 Internal Server Error
response may be returned.
If a response is expected to be generated by another module, a
.B 504 Gateway Timeout
response will be generated if the response timeout is reached.
.PP
With default configuration, no RRR messages are generated by
.B httpserver,
and any received (and valid) request gets a
.B 204 No Content
response.
.PP
.Bl -tag -width -indent
.It RRR array message with fields
Any configured fields from GET, POST or query string in the endpoint are put into an RRR array message.
If full request receive is active, fields generated here will be put into the same message. Array messages will have the topic
.B httpserver/request/uuu
set, where
.B uuu
is a unique ID. Configured fields are not retrieved for requests with the
.B OPTIONS
method. 
.El
.PP
The IDs are unsigned desimal numbers which increase by 1 for every received request, also if they do not cause any RRR
messages to be generated. 
.PP
The following configuration parameters are available in the
.B httpserver
module:
.PP
.Bl -tag -width -indent
.It http_server_transport_type={tls|plain|both}
Listen with TLS mode, plaintext mode or both. Defaults to 'plain'.

.It http_server_port_tls=PORT
Port to use for TLS listening, defaults to 443.

.It http_server_port_plain=PORT
Port to use for plaintext listening, defaults to 80.

.It http_server_fields_accept=HTTP FIELD[->ARRAY TAG][,...]
Specify a comma separated list POST and GET fields to allow from clients. Fields not specified here are ignored unless
.B http_server_fields_accept_any
is set to 'yes'.
An optional array tag may be specified for each field if the field name should be translated when added to the RRR array message.
This parameter is optional.

.It http_server_fields_accept_any={yes|no}
Accept any field names from incoming requests. May not be used with
.B http_server_fields_accept. 
Defaults to 'no'.

.It http_server_allow_empty_messages={yes|no}
Create RRR messages for incoming request even if no field names would be added to the message. Defaults to 'no'.

.It http_server_receive_full_request={yes|no}
Get HTTP data from the request and add it to an RRR array message along with any fields from POST and GET. 
The fields
.B http_method, http_protocol, http_endpoint, http_body, http_content_transfer_encoding
and
.B http_content_type
will be added. The latter two values will only be added if present in request header, and the body only if the request body has non-zero length.
These fields are always added regardless of other options, except from the
.B http_server_allow_empty_messages
option which need to be set to 'yes' for HTTP requests with zero length body to be processed.
The generated RRR message will have a topic of
.B httpserver/request/uuu
where uuu is a unique ID for one HTTP connection.
.B http_protocol
is either 1 or 2. Defaults to no. 

.It http_server_get_response_from_senders={yes|no}
If this option is set to 'yes', a sender of
.B httpserver
is expected to generate HTTP responses. Imples
.B http_server_receive_full_request=yes.

A module which receives the RRR message containing the response may generate a response structured in an RRR array message with the following fields of which all are optional:
.sp
.Bl -tag -width -indent
.It http_response_code
The response code and text to use in the response, defaults to 200 or 204 depending on whether or not any data is present
(httpserver will implicitly force use of 200 if the status is 204 and a body is present).
Must be a value >= 100 and <= 599, 200 or 204 will be selected silently if the provided code is out of this range.
.sp
.It http_content_type
The content type to use for the response. If it is defined but is an empty string, no content type header will be sent.
If not defined, the content type sent will depend on the type of the
.B http_data
field.
In any case, a content type header will not be sent if there is no request body.

.It http_body
The response body to send. The content type set in the response header, unless specified explititly in 
.B http_content_type,
depends on the type of this field:
.sp
.Bl -tag -width -indent
.It blob
application/octet-stream
.It msg
application/rrr-message
.It str
text/plain (also used by other types convertible to strings (numbers etc.))
.It vain
No response body generated
.El
.sp
.El

The response message may also be a plain data message in which the data of this message will be treated the same way as data from the
.B http_body
field with blob type. The other fields will in this case get default values per above rules.

If set to 'no' or left unset,
.B httpserver
will generate default responses.

.It http_serve_response_timeout=MILLISECONDS
How long to wait for a response from senders before timing out and generating a
.B 504 Gateway Timeout
response.

.It http_server_allow_origin_header=STRING
If defined, httpserver will send an
.B Access-Control-Allow-Origin
header with the given string in all response headers.
The header is mainly used by web browsers, look online for documentation on what it does.
Using the header, in particualar setting it to * (which means to allow all origins), may have
.B security implications.

.It http_server_cache_control_header=STRING
If defined, httpserver will send a
.B Cache-Control
header with the given string in all response headers.

.It http_server_websocket_topic_filters=MQTT TOPIC FILTER[,MQTT TOPIC FILTER,...]
If specified, connection upgrades websocket version 13 will be supported if the endpoint of the URL received from the client matches
with one or more of the specified topic filters.
The full URL except from the first / of the URL and the query string (after ? inclusive) is used as the MQTT topic.

By default, the text from websocket text frames will be put into RRR messages for other modules to pick up.
These messages will have a topic identifying the current connection, like
.B httpserver/websocket/uuu/TOPIC
where
.B uuu
is a unique ID identifying the websocket connection and
.B TOPIC
is the topic set in the URL endpoint.
The unique ID will be the same as for any HTTP message received previously on the same connection, which might or might not have caused
RRR messages to be generated depending on other configuration options.
By default, no websocket connection upgrades are accepted.

If
.B httpserver
receives messages from it's senders beginning with
.B httpserver/websocket/uuu,
these messages will be forwarded to the active websocket connection with the ID specified in
.B uuu
as text frames.
Messages received in httpserver with IDs not matching any active connections will be dropped.

.It http_server_accept_websocket_binary={yes|no}
Allow binary websocket frames. Data from such frames are put into plain RRR messages.
If set to no or left undefined, received binary frames will be ignored. 

.It http_server_receive_websocket_rrr_message={yes|no}
If set to yes and websocket frames of binary type is received, these are interpreted as being RRR messages of any type.
RRR message validation and endian conversion will be performed, and the socket will be closed if this fails. Implies
.B http_server_accept_websocket_binary=yes.
Messages of text type are not affected by this parameter.
If set to no or left unset, binary messages are either ignored or received as-is depending on the value of
.B http_server_accept_websocket_binary.

.It http_server_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional.
.El
.PP
With default configuration, having no parameters specified, no RRR messages will be generated for received requests.
.PP
Note that all incoming request have to use
.B HTTP/1.1
as protocol version, any other versions will be rejected.

.SS httpclient (PAI)
This module takes RRR messages from other modules and sends them to an HTTP server. Array values in received messages
may be sent as HTTP form fields. GET and POST are supported using either HTTP or HTTPS. This module does not
use any data sent from the server, any data received is ignored.
.PP
The following configuration parameters are available in the
.B httpclient
module:
.PP
.Bl -tag -width -indent
.It http_server=SERVER OR IP
.It http_port=PORT
Server and port to send data to, defaults to 'localhost' and the default port depends on the
chosen transport type (TLS/Plain).
.B httpclient
will follow any redirects from the server, also to other servers.
To disallow redirection, use the
.B http_max_redirects
parameter.
 
.It http_endpoint=ENDPOINT
The endpoint to request from the server, e.g.
.B /index.php.
If the server responds with a redirect, this new endpoint will be used.
It is possible to specify a query string in the endpoint, like
.B /index.php?a=1&b=2.
If the server responds with redirect, this query string will not be included in the folling request.
If GET method is used, any query values from RRR messages will be appended to the query string, also if there are redirects.
.B httpclient
will detect whether a query string already exists in the URL and prefix the first parameter with either ? or &.
Defaults to
.B /.

.It http_transport_type={tls|plain|both}
If transport type is set to 'plain' or 'tls', HTTP or HTTPS will be
.B enforced,
which means that redirects fro the server to a different transport type than the chosen one will be rejected.
Use 'both' or leave unspecified for automatic transport type.

.It http_version_10={yes|no}
If set to yes, protocol version HTTP/1.0 is used when sending requests and upgrade to HTTP/2 will not be requested, also not using TLS ALPN.
If set to no or left unspecified, HTTP/1.1 will be used and upgrade to HTTP/2 will be requested to the server with all queries.

In case of an upgrade request, the server will either allow upgrade to HTTP/2 and continue using that or simply respond with HTTP/1.1 or HTTP/1.0.

Some HTTP servers always respond with either version HTTP/1.1 or HTTP/1.0 regardless of which version the client used in the request.
If the server responds with HTTP/1.0, the connection will be closed just after a response have been received.
If the server responds with HTTP/1.1, the connection will be kept alive for a few seconds before being closed if no other requests are to be sent

.It http_method={get|put|post|head|delete|options}
Which method to use when sending data to the server. Defaults to
.B get.

.It http_format={urlencoded|multipart|json|raw}
Control which body format to use for PUT and POST requests. If the
.B raw
mode is set, messages which does not contain a body (specified in the tag named in
.B http_body_tag
) will trigger an error as they are processed.
Messages with a body are otherwise not affected by this parameter.
Defaults to 'urlencoded'.

.It http_taint_tag=ARRAY TAG
The specified tag of vain type will be added to generated response messages of array type.
In addition, any received messages from senders in which this tag is present will be ignored.
If left unset, no taint tag will be used.

\(bu If
.B get
is used, any fields will be appended to the endpoint after a questionmark ?. GET requests have no body.
.br
\(bu If
.B post_urlencoded
is used, any fields will be made into a query string and sent in the POST body of type 'application/x-www-form-urlencoded'.
.br
\(bu If
.B post_multipart
is used, any fields will be made into separate mime parts and sent in the POST body of type 'multipart/form-data'. This method is recommended for large data fields.

.It http_endpoint_tag=ARRAY TAG
.It http_method_tag=ARRAY TAG
.It http_server_tag=ARRAY TAG
.It http_port_tag=ARRAY TAG
.It http_body_tag=ARRAY TAG
.It http_format_tag=ARRAY TAG

.It http_endpoint_tag_force={yes|no}
.It http_method_tag_force={yes|no}
.It http_server_tag_force={yes|no}
.It http_port_tag_force={yes|no}
.It http_body_tag_force={yes|no}
.It http_format_tag_force={yes|no}
These options allow the default endpoint, server and/or port to be overridden by array values in messages from senders of httpclient,
identified by the tag of the value.
If the
.B force
options are set to yes, the specified tags are required to be present in all messages and non-conforming messages will be dropped.

Values from the message, although they will be attempted converted, should be of the
.B str
type, event binary data. The
.Xt mangler (PA)
module can be used to convery values if needed.
The endpoint, method, server or port must not contain any NULL characters.

If the HTTP server responds with a redirect, the redirection will be followed and values from the messages will not be used except from the HTTP method.
To disallow redirection, use the
.B http_max_redirects
parameter.

Any endpoint from the message may contain a query string, in which any other parameters will be appended to this query string if GET method is used with array values.

If
.B http_body_tag
is used and an HTTP body is found in the message, any array tags specified will be ignored.
If the HTTP method being used does not have a body, like GET, the body data parameter is ignored silently.
The content-type of the resulting request will be 'application/octet-stream'.

The parameters
.B http_method_tag
and
.B http_format_tag
are used to override the request metod and body format of HTTP requests.
They correspond to the configuration parameters
.B http_method
and
.B http_format
resectively, and the same values may be used in the messages.

Any value specified for HTTP format in a message is ignored if a HTTP body is also present (precence of body implies 'raw' format).

.It http_meta_tags_ignore={yes|no}
Ignore the above defined tags when array values to the HTTP query (controlled by)
.B http_tags.
If set to no, the meta fields may be added to query string or form data body as any other field. Defaults to yes. 

.It http_endpoint_from_topic={yes|no}
.It http_endpoint_from_topic_force={yes|no}
If
.B http_endpoint_from_topic
is set to yes, the MQTT topic of received messaged will be used as the HTTP endpoint. A slash / will be prepended to the topic.
If force is set to yes, messages without a topic will be dropped.
May not be used together with
.B http_endpoint_tag.

.It http_msgdb_socket=PATH
If this parameter is set with a path to the listening socket of the
.B msgdb
module (message DB), filesystem storage of any failed PUT requests will be activated.
The message DB module must also have an instance in the confiuration and listen on the same socket,
but it is not a requirement that it is run by the same instance of RRR.

Any stored messages will not be deleted from the database until a successful request has been performed.

The messages will be indexed by using the mqtt topic of the messages, and messages without topics cannot be stored.
If a message is to be stored in the message DB while a message with the same topic already exists, the old message will be overwritten.

Messages are guaranteed to be sent to the server
.B at least once
, and it is possible under certain server failure conditions and/or high load that some  messages may be sent twice to the server.

Note that if the same msgdb is used for multiple
.B httpclient
instances, an instance will find messages from the others.

Refer to the
.B msgdb
section for more details.

.It http_msgdb_poll_interval_s=SECONDS
Number of seconds between each index request to the message db server, defaults to 30.

.It http_fields=HTTP FIELD NAME[=VALUE][,...]
.It http_tags=ARRAY TAG[->HTTP FIELD NAME][,...]
.B http_tags
is a comma separated list of array tags to find in RRR messages from other modules.
If left unspecified, all array values found will be sent to the HTTP server in default configurations.
If a tag is postfixed with a
.B HTTP FIELD NAME,
this name instead of the array tag name when sending data to the HTTP server.
If tags are specified and an RRR message from a sender is missing one or more of the specified tags, an error is produced.

.B http_fields
is a set of fixed fields to send to the HTTP server, optionally with values. Values from
.B http_fields
are sent regardless of the configuration of
.B http_tags.

If a message is to have it's raw body sent in a PUT or POST request, controlled by
.B http_body_tag,
fields from these parameters will not added to the query.

.It http_rrr_msg_to_array={yes|no}
Convert fields in RRR messages from other modules to array values. The fields used are
.B timestamp, topic
and
.B data.
These values may be used in the same way as any other array values from the messages, they may also be matched in the
.B http_tags
parameter. If
.B http_tags
is specified, values from the RRR message will only be sent if they are specified here. Defaults to 'no'.

.It http_no_data={yes|no}
Ignore all data in RRR messages from other modules. Only query values in
.B http_endpoint
and
.B http_fields
, if specified, will be sent to the server. Defaults to 'no'.

.It http_drop_on_error={yes|no}
If there is any error with sending a message while connecting to the server, drop it.
Errors will be logged regardless of this setting.
PUT messages which are stored in the message DB will be retried at the next message DB poll should they be dropped as a result of a connection error (see
.Xr http_msgdb_socket
).
Defaults to 'no' which means that connecting will be retried until a timeout is reached or indefinitely.

.It http_message_timeout_ms=MILLISECONDS
Timeout for deferred messages, defaults to 0 which means no timeout.
Messages being defered to fhe message DB (see
.Xr http_msgdb_socket
) will not get affected by this parameter, as the timer is reset every time they are read back from the DB.
Note that the timeout, if set too low, might cause messages to get dropped before any request has been produced.
If the timeout is set too high or is not set, messages may accumulate in memory.

.It http_ttl_seconds=SECONDS
When the time timestamp of a message in the send queue becomes older than the specified amount of seconds, it is dropped.
The message will also get deleted from the message DB if used (see
.Xr http_msgdb_socket
).
Defaults to 0 which means that TTL check is not performed.

.It http_max_redirects=UNSIGNED INTEGER
The maximum number of redirects to allow from the server for a single message. May be set to 0 to disallow redirects. Defaults to 5, maximum is 500.

.It http_accept=STRING
If specified, an Accept: header field will be sent with all requests containing the given value. If
.B http_accept=application/json
is specified,
.B Accept: application/json
will be sent to the server. Note that it is not possible to specifiy a value with newlines.

.It http_receive_part_data={yes|no}
.It http_receive_json_data={yes|no}
Any combination of yes and no is allowed for the receive options. By default, no messages are generated by
.B httpclient

When receiving part data, HTTP response data is put into messages for other modules to read from httpclient.

When receiving JSON data, multiple RRR array messages may be generated for every response.
Every JSON object containing bare associative values will result in a separate RRR message, regardless of of it's position in the object tree.
A good solution might be to have the server send one or more JSON objects representing data records, all contained in a JSON array.
A maximum of four object tree levels are parsed.

Httpclient will attempt to parse any received data as JSON, regardless of what content type has been set.
Should the parsing fail, no error messages are printed unless debuglevel 2 is set.  

If the original message which caused the query had a topic set, this topic will be present in generated messages. 

.It http_receive_structured={yes|no}
If set to yes, generated messages will be RRR array messages. The following fields will be available in the messages:

.Bl -tag -width -indent
.It http_response_code
The HTTP response code.
.sp
.It http_content_type
The content type from the HTTP header, or empty string if not present.
.sp
.It http_body
The raw response body, or empty string if not present.
.El

The
.B http_body
tag will not be present for JSON messages.
Also, if the JSON data in the response contains any of the above fields, both will be present in the message
with the HTTP-response fields being placed first.

.It http_receive_ignore_error_part_data={yes|no}
If set to no, attempts will be made to create messages from the part data of any responses from the server, even
if they are error responses (HTTP response code is less than 200 or more than 299).
If set to yes or left unset, no messages will be generated from error responses.

.It http_receive_404_as_empty_part={yes|no}
If set to yes and a 404 NOT FOUND response is received, an empty RRR data message will be created.

If set to no or left unset, no such messages are created upon 404 responses.

This parameter is not affected by
.B http_receive_ignore_error_part_data
and does not affect any other parameters.

.It http_low_priority_put={yes|no}
If set to yes, messages which are to be sent using the PUT method will be prioritized behind other messages. This
can improve performance in certain applications if stores are slow.
If set to no or left unset, PUT messages will be treated as other messages.

.It http_plain_http2={yes|no}
In non-TLS mode, send requests using HTTP2 without upgrading through HTTP/1.1. Note that some servers may get confused by this (but the RRR httpserver module supports it). Defaults to no.
This parameter is ignored if
.B http_version_10
is set to yes.

.It http_concurrent_connections=UNSIGNED INTEGER
Maximum number of concurrent connections to open for each host/port combination. Defaults to 10, minimum value is 1 and maximum value is 65535.

.It http_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional.
.El
.SS msgdb (N)
The message DB saves messages on the file system for persistence across program restarts.
Clients may connect to the message DB using a UNIX socket and perform REST-like (REpresentional State Transfer) queries to save and retrieve messages.

Messages are stored with their filename being the SHA-256 hash of their topic. Messages with empty topics cannot be stored.

Using the socket is the only way to communicate with the message DB, it cannot read from other modules nor can it be read from.

Currently only internal modules may use the message DB, and the methods GET, PUT, DEL and IDX are available to them. 

Messages are stored with all fields in network byte order. They are checksummed, and any modifications will stop the message DB from reading them.

Messages may be deleted manually from the database directory at any time, or moved out and back in.
They should however not be renamed or moved inside the hirarchy as their location would then no longer match the topic set inside the message.

.Bl -tag -width -indent
.It msgdb_directory=DIRECTORY
The directroy to store files in. Defaults to '/var/lib/rrr/msgdb'.
Multiple instances of the Message DB should not use the same directory.

.It msgdb_socket=FILENAME
The path to the socket to which clients connects. Defaults to '/var/run/rrr/msgdb.sock'.
.El

.SS incrementer (PA)
Incrementer will append unique ID numbers to messages matching a specified topic filter.
If wildcards are present in the filter, an separate ID counter will be used for each unique topic matching the filter.
The ID counters may be initialized by passing in messages with a start ID value in a specific tag, or they may begin at
the lowest allowed value. If a message DB socket is specified, the latest used ID's will be stored on disk for
persistence across restarts.

When messages are allocated an ID, a number following a slash / is appended to the topic before the messages
are sent to the output buffer for other instances to pick up.

If a message with the topic
.B my/topic-a
is given to incrementer and matches the active configuration, the topic will be changed to
.B my/topic-a/UUU
where UUU is the allocated numberic ID. The allocated IDs are 32-bit unsigned integers which gives a maximum value of 4.294.967.295
which when reached wraps back to the minimum value.

.Bl -tag -width -indent
.It incrementer_subject_topic_filter=MQTT TOPIC FILTER
The topic filter for messages to process, required parameters. Wildcards # and + are allowed per MQTT standards.
Messages received which do not match will be passed through to the output buffer unmodified.
To prevent other messages from being received to incrementer all together, set the same filter in the general
.B topic_filter
parameter.

.It incrementer_msgdb_socket=PATH
If specified, used IDs will be stored on disk using Message DB. An instance of
.B msgdb (N)
must be running and listening on the socket.

.It incrementer_id_tag=TAG
If specified, all topics for which to allocate IDs must be pre-initialized. This is done
by passing a message to
.B incrementer
with the same topic 

.It incrementer_id_min=UNSIGNED INTEGER
The lowest ID to allocate, defaults to 1.

.It incrementer_id_max=UNSIGNED INTEGER
The maximum ID to allocate, default to 4.294.967.295.

.It incrementer_id_modulus=UNSIGNED INTEGER
The modulus (increment step) to use, defaults to 1 which is also the minimum value. Maximum value is 255.

.It incrementer_id_position=UNSIGNED INTEGER
The position within the modulus to use for IDs. Defaults to 0, maximum value is 254 and must be less than modulus.
.El

The max and min values must otherwise be set so that the modulus fits between them.
The consistency of the configuration parameters will be checked during startup.
Any ID which after incrementation gets a value less than min or more than max will
be reset to a low value matching the modulus and position parameters.

The algorithm used for calculating ID numbers:

\(bu IDo  = Old ID (last allocated)
.br
\(bu IDn  = New ID
.br
\(bu IDl  = Lowest ID
.br
\(bu IDh  = Highest ID
.br
\(bu m    = Modulus
.br
\(bu p    = Position

.nf
IDn1 = IDo - (IDo mod m) + m + p

If IDn1 < IDl or IDn1 > IDh, then IDn2 = IDl - (IDl mod m) + p
                             else IDn2 = IDn1

If IDn2 < IDl, then IDn = IDn2 + m
               else IDn = IDn2
.fi

\(bu If the modulus is set to 2 and position set to 0, only even IDs will be allocated.
.br
\(bu If the modulus is set to 2 and position set to 1, only odd IDs will be allocated.

.SS cacher (PA)
The
.B cacher
uses a message database to store messages on disk.
Messages received are stored into the database, and it is possible to have messages read back
by passing in request messages.

.Bl -tag -width -indent
.It cacher_msgdb_socket=PATH
An instance of
.B msgdb (N)
must be running and listening on this socket.
All messages received will be sent to the specified message database for storage, unless the messages
are request messages. Only one message per unique topic will be stored. Mandatory parameter.

.It cacher_request_tag=TAG
If the specified tag exists in a message, the message will be treated as a request message.
The topic of the message is used to search in the message database, and if a message exists with the same topic, this
message is passed to the output buffer.
Optional parameter.

.It cacher_forward_requests={yes|no}
If set to yes, messages which are treated as requests are passed to the output buffer.
Defaults to no.
See also
.B cacher_memory_consume_requests.

.It cacher_forward_data={yes|no}
If set to yes, messages which are not treated as requests (thus are to be stored) are passed to the output buffer.
Defaults to no.

.It cacher_forward_other={yes|no}
If set to yes, messages without topic are forwarded.
If set to no or left unset, messages without a topic are dropped and an error message is produced.

.It cacher_memory_consume_requests={yes|no}
If set to yes and a request matches a message in the memory cache, the request will not be forwarded regardless of the
.B cacher_forward_requests
parameter.
If set to no or left unset, the parameter
.B cacher_forward_requests
will control whether the request is forwarded or not.

.It cacher_empty_is_delete={yes|no}
If set to yes, an empty message which otherwise would be stored will instead cause deletion of any previously stored message with mathcing topic.
If set to no, empty messages will be stored.

.It cacher_no_update={yes|no}
If set to yes, no writes will be performed and all messages which are not requests will be treated as 'other'.
Defaults to no.

.It cacher_ttl_seconds=SECONDS
Any messages received from other modules with an age older than the set value is silently dropped.
In addition, the age of messages in the message database is checked every 5 minutes and expired messages are deleted.
Defaults to 0 which means that TTL check is not performed.

.It cacher_memory_ttl_seconds=SECONDS
Messages which are to be stored in the message database will also be stored in the memory cache and deleted after this specified TTL expires.
When a request message is received and a matching message is found in the memory cache, the cached message will be passed to the output buffer and the message database will not be consulted.
The memory cache is checked for TTL when potential matches are found or every 5 minutes.
If set to 0 or left unset, memory cache is not used.

.El

.SS mqttbroker (N)
An MQTT broker supporting V3.1(.1) and V5.
.PP
The following configuration parameters are available in the
.B mqttbroker
module:
.PP
.Bl -tag -width -indent
.It mqtt_broker_port=PORT
TCP port to listen on (listens on all interfaces). Defaults to 1883.

.It mqtt_broker_port_tls=PORT
TCP port to listen on for TLS connections (listens on all interfaces). Defaults to 8883.

.It mqtt_broker_transport_type={plain|tls|both}
The transport type to use when listening. Defaults to 'plain'.

.It mqtt_broker_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional except from certificate file and private key.
.It mqtt_broker_max_keep_alive=SECONDS
Maximum keep-alive value for clients, defaults to 30.

.It mqtt_broker_retry_interval=SECONDS
Retry interval for QoS1 and QoS2 messages.

.It mqtt_broker_close_wait_time=SECONDS
After disconnect, wait this many seconds before closing the socket (make client close first to avoid TIME_WAIT). Defaults to 1 second.

.It mqtt_broker_v31_disconnect_on_publish_deny={yes|no}
If a V3.1 or V3.1.1 client sends a PUBLISH which is rejected by ACL rules, the client will be disconnected
if this option is set to yes. The default value is no, which means that the broker sends an acknowledgement packet
regardless of whether the PUBLISH was rejected or not. For V5, an acknowledgement with an error code is always sent,
disregarding this option.

.It mqtt_broker_password_file=FILENAME
Filename of an RRR password file created by
.Xr rrr_passwd(1)
with which users are authenticated. If left unspecified, all CONNECT packets containing a username will be rejected.
RRR does not allow CONNECT packets only containing usernames, a password must always be set.

.It mqtt_broker_permission_name=PERMISSION
The permission name to which a user must have been registered with by using
.Xr rrr_passwd(1)
to become authenticated with this broker. Defaults to
.B mqtt. 

.It mqtt_broker_require_authentication={yes|no}
Disallow anonymous logins. This defaults to 'yes' if a password file is set, otherwise it defaults to 'no'.

.It mqtt_broker_acl_file=FILENAME
ACL file to allow different users access to topics. If left unspecified, all access is granted. If a file is specified and a rule
is not found upon a PUBLISH or SUBSCRIBE from a client, access will be denied.
.PP
The ACL file consists of one or more
.B TOPIC {TOPIC STRING}
blocks. The
.B TOPIC STRING
value is an MQTT filter in which # and + are allowed according to the MQTT specifications. Curly brackets are not to be included.
.PP
A topic block may contain one or more lines beginning with one of the keywords
.B USER
or
.B DEFAULT
followed by one or more spaces or tabs. Keywords are case-insensitive.
.PP
The
.B DEFAULT
keyword takes one argument, an ACL action (DENY, READ or WRITE). If left unspecified, the default action is DENY.
.PP
The
.B USER
keyword takes two arguments, a username followed by one or more spaces or tabs and an ACL action (DENY, READ or WRITE).
.El
.PP
If
.B READ
access is granted, a user may SUBSCRIBE to the matching topics. If
.B WRITE
access is granted, a user may SUBSCRIBE and PUBLISH to the matching topics.
.B DENY
will block all access to the matching topics. 
.PP
The ACL file is parsed from top to bottom, and the bottom most matching rule will take precedence.
.PP
Comments may be placed on separate lines and begins with '#'. Spaces and tabs are allowed on the beginning of a line before keywords.
.PP
Below follows some example rules:
.PP
.nf
# BEGIN ACL FILE
# Allow access to everything from everyone
TOPIC #
	DEFAULT WRITE

# Allow only READ access on $SYS topics, but allow system_user to WRITE
TOPIC $SYS/#
	DEFAULT READ
	USER system_user WRITE
# END ACL FILE
.fi
.PP
The MQTT server follows the specifications from Oasis, but lacks support for the following (will be implemented shortly):
.PP
\(bu AUTH packet (simple username/password implemented)
.PP
.SS mqttclient (PA)
An MQTT client supporting V3.1.1 and V5. The client will publish RRR messages it receives from other modules, and
other modules can read messages the client receives on subscribed topics.
.PP
The following configuration parameters are available in the
.B mqttclient
module:
.PP
.Bl -tag -width -indent
.It mqtt_server=HOST
Host name or IP of the broker to connect to. Defaults to localhost.

.It mqtt_server_port=PORT
TCP port on the server for TLS connections, defaults to 1883 for plain transport and 8883 for TLS connection.

.It mqtt_transport_type={plain|tls}
The transport type to use when connecting to the server. Defaults to 'plain'.

.It mqtt_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional.

.It mqtt_client_identifier=IDENTIFIER
Client identifier to use. If left unspecified, the broker picks one.

.It mqtt_v5_recycle_assigned_client_identifier={yes|no}
If we let the broker pick a client identifier and we are using protocol version 5, the broker will inform the client
about which client identifier it assigned. If this option is set to yes and the client needs to re-connect for some reason,
it will attempt to use this assigned client identifier. In version 3, the broker does not inform the client about the
picked client identifier and this option is then ignored. Defaults to 'yes'.

.It mqtt_connect_error_action={restart|retry}
Default action if connecting to the server failed. If set to
.B restart,
all RRR modules will be restarted after a few connection attempts (might cause messages to be lost). If set to
.B retry,
the client will keep trying to connect without any restart (messages will not be lost). Default action is to restart.

.It mqtt_connect_attempts=NUMBER OF ATTEMPTS
How many times we attempt connecting to the broker before giving up.
What we do when this number is reached depends on the setting
.B mqtt_connect_error_action.
One connection attempt lasts approximately 100ms. Must be 1 or more, defaults to 20.

.It mqtt_discard_on_connect_retry={yes|no}
With this option set to 'yes' while
.B mqtt_connect_error_action
is 'retry' and a connect retry is performed, queued messages will be read from all senders and discarded. This might be needed
to avoid non-processed messages filling up memory in situations where the broker is not available for a longer period. If however
.B  mqtt_connect_error_action
is 'restart', all messages will be cleared anyway when all instances restart after mqttclient fails to connect.
.B mqtt_discard_on_connect_retry
may not be set to 'yes' in this situation. Defaults to 'no'.
  
.It mqtt_username=USERNAME
.It mqtt_password=PASSWORD
Optional username and password to send in CONNECT packets. If a password is set, a username
.B must
also be set. Note that the RRR MQTT broker disallows connects with username only, other brokers might handle this differently.

.It mqtt_qos={0|1|2}
Default Quality of Service to use, defaults to 1.

.It mqtt_version={3.1.1|5}
Default MQTT protocol version to use, defaults to 3.1.1.

.It mqtt_publish_topic=TOPIC
Topic to use when publishing RRR messages without topic set in them.
If left unspecified, RRR messages without a topic will be dropped.

.It mqtt_publish_topic_force={yes|no}
Force use of the topic specified in
.B mqtt_publish_topic
and disregard any topic in RRR messages. Cannot be used with
.B mqtt_publish_topic_prepend.
Defaults to no.

.It mqtt_publish_topic_prepend={yes|no}
The topic specified in
.B mqtt_publish_topic
is prepended to the topic RRR messages. No trailing or leading slashes are added. Cannot be used with
.B mqtt_publish_topic_force.
Messages without a topic are dropped if set to yes. Defaults to no.

.It mqtt_publish_rrr_message={yes|no}
If set to yes, the client will send full RRR messages.
If set to no, the raw data field of each RRR message will be sent, or a descriptive string with the message
type, class and timestamp is put into the publish payload for messages which do not have any data. Defaults to yes.

.It mqtt_publish_array_values={*|tag1[,tag2[,...]]}
Put all values from an array (*) or selected values (by tag) into the payload of PUBLISH messages. RRR
messages which does not contain an array are dropped. Any integer types will have big endianess in the resulting publish message.
Cannot be used with
.B mqtt_publish_rrr_message=yes.

.It mqtt_subscribe_topics=TOPIC1[,TOPIC2[,...]]
MQTT topic patterns to subscribe to (if any)

.It mqtt_receive_rrr_message={yes|no}
Expect to receive RRR messages from the broker.
If set to yes, any messages received which are not RRR messages are dropped.
If set to no and protocol version is V3.1.1, any data in messages received are put into a new RRR message.
If set to no and protocol version is V5, type of the received message is auto-detected.
Defaults to no.

.It mqtt_receive_publish_topic={yes|no}
When an RRR message is found inside a received PUBLISH and this parameter is set to 'yes',
modify the RRR message and replace its topic with the topic from the PUBLISH message.
If set to 'no' or left unset, the RRR message will retain is original topic, if any.

.It mqtt_receive_array=ARRAY DEFINITION
If set, expect to receive data arrays of specific formats in publish messages.
This option cannot be used with mqtt_receive_rrr_message=yes, however if protocol version is V5,
received RRR messages will still be auto-detected, and array parsing will not occur for these.
Multiple data array records may reside in a single PUBLISH message, one RRR message will be generated for each record. 
Refer to
.Xr rrr_post(1)
for syntax of array definitions.
.El
.SS journal (SA)
Picks up RRR journal log messages and places them into arrays for other modules to read. Please note that this is not possible
to do with certain debuglevels active as passing messages generated by
.B journal
would cause generation of even more messages at an exponential growth rate.
.PP
RRR log messages from
.B journal
will have their MQTT topic set to
.B rrr/journal/{log_prefix}
where {log_prefix} (without curly brackets) is set by the originating module. It is not possible to change this topic,
but it may be changed in other modules which use these messages if required. See more details further down.
.PP
If a global debuglevel other than 1 is active, ...
.PP
\(bu all messages with a loglevel other 1 will be suppressed.
.br
\(bu messages from custom scripts which generate log messages (regardless of debuglevel) on other loglevels than 1 will be suppressed.
.br  
\(bu all log messages are still delivered to
.Xr rrr_stats(1)
and printed out (and delivered to syslog if RRR is an systemd daemon).
.PP
The following array tags can be retrieved from messages generated by
.B journal:
.PP
.Bl -tag -width -indent
.It log_level_translated
RFC 5424 loglevel, small integer.
.It log_prefix
The log prefix, usually path to the current RRR configuration file.
.It log_message
The actual log message (including syslog-syntax for loglevel and prefix)
.It log_hostname
The hostname of the current host or overridden hostname from configuration file.
.El
.PP
Messages generated while RRR is processing a signal are not delivered to
.B journal.
.PP
The following configuration parameters are available:
.PP
.Bl -tag -width -indent
.It journal_generate_test_messages={yes|no}
Generate dummy messages for testing purposes. Defaults to no.

.It journal_hostname=HOSTNAME
Hostname to send along with log messages. Defaults to system hostname.
.El

.SS file (SA)
Reads from files, character devices, block devices, sockets and FIFO pipes.
Full file contents may be read into RRR messages, or and array definition may be used to create RRR array messages from the data.
The
.B file
module periodically checks for new entries in the specified directory and tries to read from them.
.PP
Sockets, character devices and FIFO pipes are kept open until the other end closes them or EOF is encountered.
If disconnected,
.B
file
with attempt to reconnect with them in the next probe round unless they are deleted in the meantime.
FIFO pipes can be created with the
.Xr mkfifo(1)
command, and they can be written to easily with commands like
.B echo "blabla" > /tmp/rrr/my_rrr_fifo .
.PP
The
.B file
module can be used to manage a "drop" directory where other programs put files which are to be read into RRR.
When doing this, one must avoid that
.B file
tries to read files before they are completely written out.
This can be achieved by specifying a file prefix in the configuration and writing the files first with some temporary name
before finally, when writing is complete, renaming them to something matching the prefix.
.B file
may be configured to delete files after they are read.
.PP
There is no limit on how many files, sockets etc. which can be simultaneously open.
.PP
The following configuration parameters are available in the
.B file
module:
.PP
.Bl -tag -width -indent
.It file_directory=DIRECTORY
Directory in which to probe for files to read from. Must be set.

.It file_prefix=FILE PREFIX
Optional prefix for files to read from in the chosen directory. Non-matching files are ignored.

.It file_probe_interval_ms=MILLISECONDS
Probing for new files is done immediately after startup and then periodically every time the probe interval has passed.
A value of zero is allowed, this might be CPU intensive. Defaults to 5000 ms.

.It file_topic=MQTT TOPIC
Set an MQTT topic on generated messages. Optional parameter.

.It file_input_types=ARRAY DEFINITION
Parse array data from the entries found.
Reading will stop when there is an error or when EOF is encountered.
Cannot be used with
.B file_read_all_to_message=yes,
but one of them must be specified. No default value.

.It file_strip_array_separators={yes|no}
Disregard any separator items when creating RRR array messages. Defaults to no.

.It file_sync_byte_by_byte={yes|no}
If array parsing fails according to definition, keep skipping one byte forward in the stream until a match is found.
Defaults to no, which means to only sync on boundaries of incoming messages.

.It file_read_all_to_message={yes|no}
Read all data from the entries and put it into an RRR message.
Note that this is probably not useful for sockets and character devices. Cannot be used with
.B file_input_types,
but one of them must be specified. At most 32 MiB may be read per file. Defaults to 'no'.

.It file_read_all_method={simple|structured}
May be set if
.B file_read_all_to_message
is 'yes'.
If set to 'simple', the contents of the file is put into a plain message.
If set to 'structured', the constents of the file along with metadata is put into an array array message.
For the latter, the array fields
.B data, size, path_original, path_resolved, atime, mtime, and ctime
will be present in the generated messages.

The
.B data
and
.B size
fields contain the actual raw data of the file and the it's size.  

The two
.B path_
fields contain the original path and resolved symbolic link path respectively. If there was not symlic, they are equal.

The time parameters is in epoch time format with seconds resolution and describe file access time, modification time and creation time. 

.It file_unlink_on_close={yes|no}
After an open entry for any reason closes, attempt to unlink it. Note that
.B any type of file or socket will be deleted
as long as the user running RRR has permission to do that. Defaults to 'no'.

.It file_max_open=UNSIGNED INTEGER
Maximum number of simultaneously open files. If multiple files are open at the same time,
.B file
will iterate all the files and read read only one message from each of the files at a time.
If there is only one open file, all messages in this file will be processed in order before
a new one is opened.
Defaults to and has a maximum value (if set) of 65536.
May be set to 0 which means that there is no maximum number of open files.

.It file_try_serial_input={yes|no}
If set to yes, an attempt will be made to set serial port parameters on opened files. If left unset or set to no, any serial configuration parameters will be ignored.

.It file_serial_no_raw={yes|no}
If set to yes, do not disable any features on serial ports. If set to no or left unset, XON/XOFF, parity, canonical reading etc. will be disabled.
Note that other configuration options for the serial ports will override this option (features may be re-enabled).

.It file_serial_bps=UNSIGNED INTEGER
If set, set a speed int bits per second like 19200, 38400 etc. on serial serial ports. If left unset, speed settings will be left untoched.

.It file_serial_parity={even|odd|none}
If set and set to 'even' or 'odd', parity will be set accordingly on serial ports. If set to 'none', parity will be forced off. If left unset, parity settings will be left untouched.

.It file_serial_two_stop_bits={yes|no}
If set to yes, use two stop bits on serial ports. If set to no, force one stop bit to be used. If left unset, stop bit configuration is left untouched. 

.It file_try_keyboard_input={yes|no} (LINUX/FREEBSD ONLY)
If set to yes, and character devices are found in the directory,
.B file
will try to read from them as if they were keyboards.
This works with many barcode scanners and other devices which produce keyboard-like event data.
Any device which accept the
.Xr ioctl(3P)
EVIOCGRAB command will be used as a keyboard, and data will be run through a key to character map.
The EVIOCGRAB command, if it succeeds, will make
.B file
the only receiver of data from the opened devices, and due to this, keyboards which are opened will
become unusable.
Care should be taken to ensure that devices are not unintentionally opened by
.B file.
Only US keyboard layout is supported.
Defaults to no.

.It file_no_keyboard_hijack={yes|no}
After a keyboard device has been successfully hijacked thus identified as a keyboard, immediately
ungrab the device so that other applications also may receive events from it. 

.It file_max_messages_per_file=COUNT
After the specified amount of messages has been read rom a file, close it.
Cannot be used with file_read_all_to_message=yes.
Defaults to 0 which means that that any number of messages will be read and the file is only closed on EOF or error conditions.

.It file_max_read_step_size=BYTES
Read as most the specified number of bytes each round.
This parameter is not respected when file_read_all_to_message is 'yes', and having both these parameter specified is an error.
Must be greater than zero, defaults to 4096.

.It file_timeout_s=SECONDS
If no message is read in the specified amount of seconds, close the file. Defaults to 0 which means no timeout. 

.El
.SS mysql (DAI)
This module will read in messages from other modules, possibly IP-capable, and save them to a myqsl or MariaDB 
database.
.PP
A column plan must be used to describe the table we are saving to. The received data must match this column plan. If
the data saving for any reason fails, like if the database is down or the table is misconfigured, we cache the failed messages
and try again later. It is not possible for the mysql module to know wether it's settings are at fault or if the database
is at fault. Messages which fails can regardless of this be set to be dropped instead upon errors.
.PP
The following configuration parameters are available in the
.B mysql
module:
.PP
.Bl -tag -width -indent
.It mysql_server=SERVER NAME
The server name of the MySQL or MariaDB server to use

.It mysql_port=PORT NUMBER
The port number used to connect to the server.

.It mysql_user=USER NAME
The username for logging into the server

.It mysql_password=PASSWORD
The password for logging into the server

.It mysql_db=DATABASE NAME
The name of the database to use

.It mysql_table=TABLE NAME
The table name to use for storing data

.It mysql_drop_unknown_messages={yes|no}
If a message fails to be saved into the specified table for any reason, simply delete it instead of trying again later. Defaults to no.

.It mysql_columns={column name 1,column name 2,...}
Specify the columns in the table to write data to. The column count must match the number of values received in array
messages from other modules. The data types only matters to some extent, the columns should be able to hold the data
types received. Integers are sent to the database as integers and blobs are sent as blobs.
If an array contains items with more than one value, one column should be specified for the whole item. These items are always sent
to mysql as blobs.
This option cannot be used with
.B mysql_column_tags.

.It mysql_column_tags=ARRAY TAG[->MYSQL COLUMN][,...]
A comma separated list of items to retrieve from the received array messages and to use as
columns in MySQL. If a tag name is specified on is own, the tag and the corresponding column in MySQL has the same name.
If the MySQL column name is different from the tag, an arrow followed by the MySQL column name is put after the tag name.
This option cannot be used with
.B mysql_colums.

.It mysql_blob_write_columns={column name 1,column name 2,...}
Used to force to send data as blob (raw data) to the database for the specified columns regardless of their type.

.It mysql_special_columns={column1=value1,column2=value2,...}
Used to write fixed values to the database.

.It mysql_add_timestamp_col={yes|no}
In addition to the other columns, write to a column named `timestamp` and save the timestamp from the message here.

.It mysql_strip_array_separators={yes|no}
Disregard any separator items in received array messages. Defaults to yes.
.El
.SS influxdb (DA)
This module receives array messages from other modules and sends their data to an Influx database using HTTP.
.PP
The following configuration parameters are available in the
.B influxdb
module:
.PP
.Bl -tag -width -indent
.It influxdb_server=HOSTNAME
The IP address or hostname of the host running an Influxdb database.

.It influxdb_database=DATABASE
The database name to use on the server.

.It influxdb_table=TABLE
The table in the database in which to store the data.

.It influxdb_port=PORT
The port to use when connecting to the server, defaults to 8086.

.It influxdb_transport_type={plain|tls}
The transport type to use when connecting to the server. Defaults to 'plain'.

.It influxdb_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional.

.It influxdb_tags=ARRAY TAG[->INFLUXDB TAG][,...]
A comma separated list of items to retrieve from the received array messages and which should be used as
.B tags
in InfluxDB. If the tag of an
item in an array is not equal to the tag in InfluxDB, the tag may be followed by
.B ->INFLUXDB TAG
to translate the tag name. 
Items in an array message which are not tagged cannot be used.

.It influxdb_fields=ARRAY TAG[->INFLUXDB FIELD][,...]
A comma separated list of items to retrieve from the array and which are to be used as
.B fields
in InfluxDB. Otherwise same rules as for tags.

.It influxdb_fixed_tags=TAG[=VALUE][,...]
Optional comma separated list of fixed tags (and optionally with values) to save to InfluxDB.

.It influxdb_fixed_fields=FIELD[=VALUE][,...]
Optional comma separated list of fixed fields (and optionally with values) to save to InfluxDB.
.El
It is required to have at least one tag specified in either
.B influxdb_fields
or
.B influxdb_fixed_fields .
.SS voltmonitor (SA)
Read voltage readings from a USB device. For every reading, an array message is generated with the timestamp of the measurement
and the measurement itself.

The measurement will be stored as a signed 64-bit integer with the tag
.B measurement.
The time of the measurment in microseconds will be stored (duplicated) in
.B timestamp_from
and
.B timestamp_to.
.PP
.Bl -tag -width -indent
.It vm_calibration=FLOAT
Factor to calibrate the readings, defaults to 1.124.

.It vm_channel={1|2}
Which channel to use on two-channel devices.

.It vm_message_topic=TOPIC
MQTT topic to apply to generated messages.
.El
.PP
.SS averager (PA)
The averager module reads point measurements from it's senders and produces average measurments over a given timespan and
at a given rate. Other messages are simply passed through.
.PP
The averager module expects to find the tag
.B measurement
in array messages from it's senders. It will generate average measurements with the following values as unsigned 64-bit integers:

.Bl -tag -width -indent
.It average
The average of the measurements received in the timespan.
.It max
The maximum value of all the measurements received in the timespan.
.It min
The minimum value of all the measurements received in the timespan.
.It timestamp_from
The lowest timestamp of all the measurements received in the timespan.
.It timestamp_to
The highest timestamp of all the measurements received in the timespan.
.El
.PP
The following configuration parameters are available in the
.B avarager
module:
.PP
.Bl -tag -width -indent
.It avg_timespan=SECONDS
How long timespan to average over. Defaults to 15 seconds.

.It avg_interval=SECONDS
How often to produce average calculations. Defaults to 10 seconds.

.It avg_preserve_points={yes|no}
Preserve individual measurements and put them in output buffer. Defaults to no.

.It avg_discard_unknowns={yes|no}
Delete messages which are not point measurements and information messages. Defaults to no, which means to simply forward them.

.It avg_message_topic=TOPIC
MQTT topic to apply to generated messages and any forwarded point messages.
.El
.SH COMMON CONFIGURATION PARAMETERS
Replace the
.B X
with the configuration paramenter prefix of the module.
.PP
.SS cmodule parameters
.Bl -tag -width -indent
.It X_workers=UNSIGNED INTEGER
How many worker fork copies to spawn. If multiple forks are used, incoming messages will be given to
the fork having the least amount of messages waiting to be processed. Note that if sourcing is used,
each for will source messages according to given parameters. Defaults to 1, maximum is 16.

.It X_source_interval_ms=MILLISECONDS
How many milliseconds to wait between each call of the source function. Defaults to 1000, one second.

.It X_sleep_time_ms=MILLISECONDS
How many milliseconds to sleep if nothing was processed in the worker after multiple processing loops.
Sleeping is performed to limit CPU usage.
It is possible to specify 0 which in practice creates a very small wait.
The worker will sleep once every round until something happens again. Defaults to 50ms.

.It X_nothing_happend_limit=UNSIGNED INTEGER
How many loops to perform in the worker with nothing being processed before starting to sleep.
Defaults to 250, must be 1 or greater.
 
.It X_log_prefix=PREFIX
Set a custom log prefix to be prepended to any log messages printed out. Use the RRR_MSG_x and RRR_DBG_x (x is a number)
macros to print messages like the reset of RRR does.

.It X_drop_on_error={yes|no}
If there is an error during processing of a message, just drop it instead of restarting the program.
Defaults to no.
.El
.SS TLS parameters
.Bl -tag -width -indent
.It X_tls_certificate_file=FILENAME
The certificate to use for TLS connections. Optional for clients, required for servers.

.It X_tls_key_file=FILENAME
The private key to use for TLS connections. Optional for clients, required for servers.

.It X_tls_ca_path=PATH[:OTHER_PATH...]
An alternative directory in which to search for CA certificates used when validating certificates. Debuglevel 1 will expose the actual search path. Optional.

.It X_tls_ca_file=FILENAME
A CA certificate file to use when validating certificates. Optional.
.El
.SH CONVERSION METHODS
The list below describes the conversion methods available in the
.B mangler (PA)
module.

Note that
.B blob2*
and
.B str2*
may accept compatible types depending on configuration.

\(bu Types compatible with
.B blob : blob, sep, msg, str

\(bu Types compatible with
.B str : str, sep, stx

.TP 10
.B h2str
Converts any numbers to strings. If an array field contains multiple values, the resulting strings will be space-prefixed to a total length of 20 characters.

.TP 10
.B h2vain
Converts integer types which are zero to vain.

.TP 10
.B blob2str
Converts blob or blob-ish fields to strings. No data manipulation is performed.

.TP 10
.B blob2blob
Converts blob or blob-ish fields to blobs. No data manipulation is performed.

.TP 10
.B blob2hex
Converts blob or blob-ish fields to hexadecimal ASCII stored in str types. The output size will be exactly double the input size. 

.TP 10
.B str2str
Converts str or str-ish fields to strings. No data manipulation is performed.

.TP 10
.B str2blob
Converts str or str-ish fields to blobs. No data manipulation is performed.

.TP 10
.B str2h
Converts str or str-ish fields to numbers, if possible.
Input numbers may be prefixed with spaces.
Unsigned are used unless one or more values are negative, in which case all values of the fields will be signed.
Overflow is not handled, and numbers may become truncated.

.TP 10
.B str2vain
Converts str fields which are empty to vain.

.TP 10
.B msg2blob       
Converts msg fields to blobs. No data manipulation is performed.

.TP 10
.B vain2h
Converts vain fields to unsigned integers with value 0.

.TP 10
.B vain2str
Converts vain fields to empty str fields.

.PP
.SH SEE ALSO
.Xr rrr(1),
.Xr rrr_post(1),
.Xr rrr_stats(1),
.Xr rrr_python3(5)
