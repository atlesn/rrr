.Dd 2023-12-05
.TH RRR.CONF 5
.SH NAME
Read Route Record is a dynamic module-based message handling program
for collecting, buffering, processing and storing messages and measurements.
.SH DESCRIPTION
The
.B rrr
environment is set up with a configuration file. The file specifies any number
of
.B instances
of different
.B modules.
The different instances either get RRR messages from other
instances, creates new messages based on some external data or send messages out. A
complete list of all available modules can be found in the MODULES section.
.PP
RRR messages may contain RRR array data, timestamp, topic and raw data.
.PP
All the different modules can read messages from each other, except from
.B source
modules which only receives data form external sources.
.PP
Custom functionallity may be achieved by using using the Perl or Python module to
run scripts inside of an RRR environment. It is also possible to write custom C or
C++ modules.
.PP
Once started,
.B rrr
keeps running until it is signalled to stop.
.PP
.SH SYNTAX
Any number of instances may be specified. An instance specification begins with a [] containing
the user chosen name of the instance, like
.B [INSTANCE NAME].
A module to use must then be specified with
.B module=MODULE NAME
. The
.B senders=SENDERS
settings is set if the instance is to read from other instances. After this, any module-specific parameters follows.
The order of parameters inside an instance specification and the order of the instances inside the configuration file
do not matter. An instance section ends when a new begins or when we reach the end of the file.
.PP
Multiple instances of a module may co-exist as long as their settings don't collide, like if they try to use the same
network ports.
.PP
.EX
# Comment are like this, they must be on separate lines. The instance name
# and module name are the ony parameters which are always required. Spaces
# around the = are ignored as well as spaces at the end of a line.

# User chosen name of the instance
[INSTANCE_1_NAME]
# Which module to use for the instance
module=MODULE NAME

# Which other instances to read from (not for source modules)
senders=INSTANCE NAME,...

# On program startup, wait for these instances to start before starting (optional)
wait_for=WAIT FOR,...

# Enable or disable output duplication (optional). If set to yes, all readers of this instance will
# receive all messages. If set to no, the readers will compete over the messages (default mode).
duplicate=yes

# Set a route definition to apply on output messages to control which reader instance messages
# are destined for (optional). If not given, or the definition produces no result, all readers
# may receive any message.

# If a route definition is given, the duplicate keyword still controls wether or not messages may be
# read by only one or multiple reader instances. To refer to a route definition specified outside
# the block, enclose its name in angle brackets like <NAME>. Multiple names may be given, in which
# the definitions will be run in order.
route=ROUTE DEFINITION|<ROUTE DEFINITION NAME>[,<ROUTE DEFINITION NAME>]...

# Set a method definition to apply on inbound messages to set the method tags given to cmodule
# processor functions. The methods tags can be used to dispatch messages to respective functions
# within the cmodule code. If multiple methods are applied to a single method, the processor function
# will be called once for each method.

# If not given, the processor function will be called with a method argument indicating that no method
# is set. If given but execution produces no result for a particular message, the processor function
# will not be called.

# To refer to a method definition specified outside the block, enclose its name in parentheses like
# (NAME). Multiple names may be given, in which the definitions will be run in order.
methods=METHOD DEFINITION|(METHOD DEFINITION NAME)[,(METHOD DEFINITION NAME)]...

# When using methods, call a named processor function directly inside the cmodule program (optional). By
# default, and if set to no, the default processor function will be called instead with the resolved method
# name as argument.
methods_direct_dispatch=yes

# Enable or disable output buffer for this instance (optional, buffer is by default enabled).
buffer=yes

# Enable or disable backstop check (optional, backstop is by default enabled).
backstop=yes

# Drop all messages from senders which do not match the set topic (optional)
topic_filter=MQTT TOPIC FILTER

# Invert topic filter (optional). If set to yes, messages in which a topic
# matches any set topic_filter will be dropped (inverted filter).
topic_filter_invert=yes

# Module-specific arguments (module-dependant)
argument1 = value1

[INSTANCE_2_NAME]
module=...

# ##### ARRAY TREE DEFINITIONS

# Any number of named array trees may be specified
# Modules parsing array data may refer to these instead of having them defined inside each instance block
{ARRAY_TREE_DEFINITION_A}
be1#type,be1#one
IF ({type} == 1)
	;
ELSIF ({type} == 2)
	be2#two
	;
ELSIF ({type} > 0)
	blob{type}#x
	;
ELSE
	err
	;
sep1#separator
;

# ##### ROUTE DEFINITIONS

# Any number of named route definitions may be specified.
# Modules with defined output routes may refer to these instead of having them defined inside each instance block.
# Use tab, newline or carriage return characters (ASCII 0x0B, 0x0A, 0x0D) to separate statements. Spaces (ASCII 0x20)
# are interpreted as any other printable character, except from when occuring after an operator or a keyword.

# Postfix notation is used, and the route definition is processed from top to bottom.

# String values are pushed to a stack by placing one of the following keywords in front of them:
# - T - Topic      - Push the result of applying the given MQTT topic filter to the topic of a message. Note that
#                    spaces are valid characters in topic filters, end the string with newlines or tabs.
# - H - Has         - Push a boolean value indicating precence of a given array tag in a message
# - D - Destinaton  - Push an instance name to the stack

# Boolean values may be pushed to the stack:
# - TRUE    - Push a boolean true to the stack
# - FALSE   - Push a boolean false to the stack

# Operators are used after pushing elements to the stack. These require one or two values to be present
# on the stack. After an operator has been run, the values are consumed and the result of the condition is
# pushed onto the stack. The route definition must be constructed such that no values are present on the stack
# after processing, which means that a route definition usually ends with one or more POP operators. If BAIL is
# used, it also counts as a POP.

# The following operators may be used:
# - AND    - Apply boolean AND on the two preceeding values and push the result.
# - OR     - Apply boolean OR on the two preceeding values and push the result.
# - NOT    - Apply boolean NOT on the preceeding value and push the result.
# - APPLY  - Set the message to be routed to the given instance or not. Requires a boolean value
#            and an instance name to be present on the stack. Leaves the boolean value on the stack.
# - POP    - Remove one value from the stack.
# - BAIL   - Stop processing if the top value on the stack is true. The value is removed from the stack.

# Comments may be indicated by using #, they may be placed anywhere except from when a value is expected.

# The parsing of a definition ends where there would be no elements left on the stack.

# Example:

<ROUTE_DEFINITION_A>
	# Push two topic filters to the stack
	T my_topic_a/+
	T my_topic_b/+
	# Run OR operator on the two stack values, leaves a boolean value on the stack 
	OR
	# Set the reader instance_receier_1 to receive messages matching one of the filters
	D instance_receiver_1
	APPLY
	# Invert the result
		NOT
	# Set the reader instance_receier_1 to receive messages not matching ant of the filters
	D instance_receiver_2
		APPLY
	# Remove the remaining value from the stack
		POP

# ##### METHOD DEFINITIONS

# Any number of named method definitions may be specified.
# Modules supporting methods (cmodule, perl5, js and python) may refer to a definition by setting the methods=
# parameter. The method definition allows messages to be matched depending on their topic or what values they
# contain. The message is then tagged with a chosen method name which later can be retrieved in the processor
# function of the module.

# Method definitions are useful when a processor module receives messages from many other modules as they provide
# a structured way of identifying the type of a message. If the programming language of the module used supports it,
# the names used in the method definition may map directly to methods or functions inside a processor script.

# Refer to the module-specific documentation on how to use the method tags inside the modules.

# The syntax for a method definition is very much like a route definition. The only difference is that the D
# operator pushes a method name to the stack.

# If a method name is applied multiple times, the last name takes precedence. The BAIL operator may be
# used to bail out once a method has been applied.

# Example:

(METHOD_DEFINITION_A)
	# Push two topic filters to the stack
	T my_topic_a/+
	T my_topic_b/+
	# Run OR operator on the two stack values, leaves a boolean value on the stack 
	OR
	# Push a method name to the stack and apply the name. Bail out if a method was set.
	M method_topic
		APPLY
		BAIL
	# Check for an array value being present in the message and push a boolean to the stack.
	H value_a
	# Set a method on the message if the value was present
	M method_value
		APPLY
	# Invert the result
		NOT
	# Set the method name to be method_b
	D method_b
		APPLY
	# Remove the remaining value from the stack
		POP

.EE
.PP
Named array tree definitions begin with {NAME} and end with a semicolon.
In all module parameters for array definitions, it is possible to instead specify {NAME} to reference a definition
from configuration file. This is useful for more complex trees which are messy to write on a single line.
Array tree definitions may be defined above or below where they are used.
See
.Xr rrr_post(1)
for array tree syntax, and in the chapters of each module below on where they can be used.
.SH RRR MESSAGES AND ARRAYS
An RRR message consists of at least a timestamp (in microseconds) and either arbitary data or
and array of values. Messages may in addition contain an MQTT topic.
.PP
Messages can either contain arbitary data or a data array.
.PP
Modules which support parsing data arrays from externally or from other modules might require a list of expected data
types to be specified in their configuration. If the total size of the input does not match the received input, parsing
of the message will fail. Some modules also generate array messages internally, and they can be created within Perl and
Python scripts. Fields from an HTTP request can be mapped into an array, and an array can be mapped into database columns.
.PP
The general syntax for an array parsing specification (without branches) is a comma separated list of types with length and item count specifications. 
.PP
.Dl type1[length1][@count1][#tag1][,type2[length2][@count2][#tag2]][,...]
.PP
The arrays are special as it is possible to have multiple values at each position. Each position has one or more values
of the exact same type and length, and may or may not have a tag (string name) identifying the particular position. Tag
names are also not unique, multiple positions may have the same tag name also with different types.
.PP
The reason for having this "2D" like structure is to group data together when receiving in such a way that it is easy
to find the different values afterwards.
.PP
Below follows a graphical representation of an array with many values. Note that there for demonstration purposes
are two values named
.B same_tag,
and that the eight byte sequence with ASCII-characters is split into two values. The string type may be of any length
enclosed by quotes "". The quotes will be removed when the value is parsed. At the second array position, there are nine
values, and at the sixth position there are two values.
.PP
.EX
+--------+-----------------+---------------------------+----------+----------+-------------+----+
| my_int |   my_integers   |                           | same_tag | same_tag | split_blob  |    |
|   1    |1|2|3|4|5|6|7|8|9| "String data without tag" |    11    |    12    | blob | abcd | CR |
+--------+-----------------+---------------------------+----------+----------+-------------+----+
.EE
.PP
An array parsing specification to produce a dataset like this (assuming the integers are 1 byte wide):
.PP
.Dl be1#my_int,be1@9#my_integers,str,be1#same_tag,be1#same_tag,blob4@2#split_blob,sep1
.PP
Refer to the
.B ARRAY DEFINITION
section of
.Xr rrr_post(1)
for the complete specification of all the types, and the specification for array trees (branching with IF-blocks).
.SS IP MESSAGES
Some messages contain IP data, for instance messages created by a module which reads from the network. The address
of the sender will be contained within the message. All modules may use IP-messages, but not all of them use the IP-data. 
.SH BUFFERS
.PP
Each instance of a source or processor module has an output buffer from which other modules read. If buffer is
disabled, a "slot" is used instead which fits a single message.
.PP
.EX
                                     3 +------------+--------+
                                     __|  INSTANCE  | Buffer |
                Duplication off     |  |     B      | / Slot |
            +------------+--------+_|  +------------+--------+
 4 messages |  INSTANCE  | Buffer |
>---------->|     A      | / Slot |_ 1 +------------+--------+
            +------------+--------+ |  |  INSTANCE  | Buffer |
                                    |__|     C      | / Slot |
                                       +------------+--------+
.EE
.PP
If an instance is specified as sender in more than one other instance, these will compete about messages from it unless
duplication is enabled. If duplication is enabled, each reader of the duplicated instance gets it's own buffer which
is filled with copies of all messages. If the buffer is disabled, all readers must make a copy of the message in the slot
after which it is deleted.
.PP
.EX
                                       +------------+--------+
                                    4 _|  INSTANCE  | Buffer |
                Duplication on       / |     B      | / Slot |
            +------------+--------+ /  +------------+--------+
 4 messages |  INSTANCE  | Buffer |-
>---------->|            +--------| 4  +------------+--------+
            |     A      | Buffer |----|  INSTANCE  | Buffer |
            +------------+--------+    |     C      | / Slot |
                                       +------------+--------+

                                       +------------+--------+
              Duplication without   4 _|  INSTANCE  | Buffer |
                    buffer           / |     B      | / Slot |
            +------------+--------+ /  +------------+--------+
 4 messages |  INSTANCE  |        |-
>---------->|            |  Slot  | 4  +------------+--------+
            |     A      |        |----|  INSTANCE  | Buffer |
            +------------+--------+    |     C      | / Slot |
                                       +------------+--------+
.EE
.PP
If buffer is disabled, the instance will block if it has a new message to write to the output while the slot is busy,
and it will proceed once a reader has picked up the message (or all readers if duplication is enabled).

Disabling buffers may reduce latency for messages, but will decrease throughout.
For very strict throughput and/or latency requirements,
experiment with using different combinations of buffer on and off as well as duplication directly in instances or separately
in intermediate
.Xr buffer(P)
instances.
If there are not thousands of messsages per second and not high bursts, buffer may be disabled for all instances to achieve the best latency possible.

The
.Xr raw(DA)
module may be used to measure performance.

.SS BUS OPERATION, CIRCULAR OPERATION AND BACKSTOP
By default, RRR has a backstop mechanism enabled which stops messages originating from an instance to be read back into the same instance.
This allows creation of a message bus and to some extent control the direction of messages in certain situations.
.PP
.EX
     BUS            NODES
+----------+   +------------+
|          |<--|  INSTANCE  |
|          |-->| httpclient |
|          |   +------------+
|          |
|          |   +------------+
| INSTANCE |<--|  INSTANCE  |
|  buffer  |-->|  python_1  |
|          |   +------------+
|          |
|          |   +------------+
|          |<--|  INSTANCE  |
|          |-->|  python_2  |
+----------+   +------------+
.EE
.PP
In the example above, the buffer instance has the other three instances set as it's senders, and the other three has the buffer
set as their only sender. This setup allows nodes to be added and removed to the bus without the need for configuring senders on
other nodes. The Python modules may then generate HTTP requests for the httpclient to perform, and httpclient generates
responses. Backstopping prevents httpclient from receiving it's own responses back to itself. The Python will however receive
HTTP requests from each other, and they must handle this in some way, possibly just ignoring them.
.PP
.EX
     BAD BUS CONFIGURATION
+------------+   +------------+
|  INSTANCE  |<--|            |
| mqttclient |-->|  INSTANCE  |
+------------+   |   python   |
                 |            |
+------------+   |            |
|  INSTANCE  |<--|            |
| httpclient |-->|            |
+------------+   +------------+
.EE
.PP
Backstopping does not work through modules with internal buffers. In the example above, the python instance is supposed to receive
requests from the mqttclient and then make HTTP requests and convert responses back to mqttclient for it to publish. When the python
instance puts the modified message in it's output buffer, both mqttclient and httpclient will receive it even though it originated
from mqttclient. The configuration can be modified to mitigate this problem, either ny using some clever topic filtering (which
may or may not be difficult to maintain) or by using a circular configuration.
.PP
.EX
   GOOD CIRCULAR CONFIGRATION
+------------+     +------------+
|  INSTANCE  |---->|            |
| mqttclient |<-+  |  INSTANCE  |
+------------+  |  |   python   |
                |  |            |
+------------+  |  |            |
|  INSTANCE  |--+  |            |
| httpclient |<----|            |
+------------+     +------------+
.EE
.PP
In the modified example, a circular configuration is used as opposed to a star configuration. When responses are generated in the
httpclient, they are only received by the mqttclient. If the HTTP response still need to be modified before mqttclient receives it,
a separate python instance may be used in between those two.
.PP
Some modules, like the buffer module, supports examining the timestamp of a message and checking this against a TTL configuration
parameter. If modules ensure that timestamps are kept intact, which they usually are, this can mitigate any erronous loops
of messages which cannot be detected by the backstop check.
.SH MODULES AND CONFIGURATION PARAMETERS
.PP
Modules have different special capabilites, denoted by the following letters. The actual implementation may
vary between modules. Many modules can despite this handle all types of messages, more or less ignoring their contents.
.PP
.Bl -tag -width -indent
.It S
Source module, can't read from other modules
.It P
Processor module, can have senders specified to read from and may also be read from other modules
.It D
Dead-end module, can only read from other modules
.It N
Network-oriented module, cannot be used as sender nor have senders specified itself.
.It A
Module supports data arrays
.It I
Module supports IP messages
.El
.PP
All modules support array and/or IP-messages, also those who do not have  
.B A
or
.B I
specified. Array- and IP-capable modules may however use or modify data from such messages.
Messages may have both IP- and Array-data simultaneously. 
.PP
The following modules are available, they are discussed in detail further down.
.PP
.Bl -tag -width -indent
.It dummy (S)
Dummy module which generates messages.

.It raw (DA)
Dumps messages, used for debugging and performance measurements.

.It ip (PAI)
Handles IP communication, UDP and TCP.

.It exploder (PA)
Splits RRR array messages into multiple messages. 

.It mangler (PA)
Converts between data types in RRR arrays. 

.It buffer (P)
Buffers messages, may be used to duplicate messages to multiple readers.

.It ipclient (PI)
Implements the RRR assured single delivery protocol on UDP for unstable connections.

.It modbus (PA)
Implements a modbus client capable of getting coil status from a remote modbus server.

.It python3 (PAI)
Processes and generates messages with custom Python3 scripts.

.It perl5 (PAI)
Processes and generates messages with custom Perl5 scripts.

.It lua (PAI)
Processes and generates messages with custom Lua scripts.

.It js (PAI)
Processes and generates messages with custom JavaScript scripts.

.It cmodule (P)
Processes and generates messages with custom C modules.

.It socket (SA)
Creates a socket to which other programs or
.Xr rrr_post(1)
can deliver data.

.It httpserver (PAI)
Spins up an nHTTP server which can parse input data into RRR array messages and generate requests.

.It httpclient (PAI)
Sends records and requests to an HTTP server.

.It incrementer (PA)
Keeps track of unique IDs and appends them to topics of messages.

.It cacher (PA)
Intermediate message on disk storage for continuity across restarts.

.It msgdb (N)
Filesystem storage engine for RRR messages (message DB).

.It mqttbroker (N)
A TLS-capable V5/V3.1(.1) MQTT broker supporting TLS, authentication, ACL.

.It mqttclient (PA)
Subscribes to MQTT topics and/or publishes messages. TLS-capable V5/V3.1(.1) MQTT client.

.It journal (SA)
Traps log messages from all modules and saves them into RRR messages.

.It file (PA)
Reads from files, sockets, character devices and FIFO pipes.

.It mysql (DAI)
Saves records to a MySQL or MariaDB table.

.It influxdb (DA)
Saves data to an InfluxDB database.

.It voltmonitor (SA)
Reads from a USB voltmeter.

.It averager (PA)
Collects point measurements and calculates average values.
.El
.SS dummy (S)
This module constantly generates empty messages, optionally containing some dummy data.
.PP
The following configuration parameters are available in the
.B dummy
module:
.PP
.Bl -tag -width -indent
.It dummy_no_generation={yes|no}
No messages are generated, defaults to yes.

.It dummy_no_sleeping={yes|no}
Don't sleep between creating messages, but create as many messages as the reader can handle, limited by automatic ratelimiting. Defaults to no.

.It dummy_no_ratelimit={yes|no}
If set to yes, automatic ratelimiting will be disabled even if
.B dummy_no_sleeping
is set to yes. Defaults to no.

.It dummy_sleep_interval_us=MICROSECONDS
The interval to sleep between each generated message. Cannot be set to 0, defaults to 50000 (50 ms). The sleep time is an approximate value. This parameter is ignored if
.B dummy_no_sleeping
is set to yes.

.It dummy_max_generated={unsigned number}
Stop generating messages after this number is reached. 0 value or not defined means that generation will never stop.

.It dummy_random_payload_max_size={BYTES}
When generating messages, give them an empty payload with a random size in the range 0 to BYTES. Default is 0 (no payload for messages).
Cannot be set together with
.B dummy_array_tag.

.It dummy_topic={TOPIC}
Set an MQTT topic in generated messages.

.It dummy_array_tag={TAG}
If set, array messages will be created containing a single value of type vain with the specifed tag.
Cannot be set together with
.B dummy_random_payload_max_size.
.El

.SS raw (DA)
This module reads messages from senders and drops them possibly after collection information from them.
.PP
If debuglevel 1 is active, statistics will be printed every second for performance measurement.
The statistics will show the current throughput and the average message lifetime of all messages based on their timestamp.
If per-message debugging is active, the lifetime will be printed for each message possibly along with array dumps and other information.
.PP
Debuglevel 3 will make a short summary of each message received be printed.
.PP
.Bl -tag -width -indent
.It raw_print_data={yes|no}
Print the timestamp of each received message and dump any arrays present in the messages. The global debuglevel 2 must
be set for messages to be printed.
.El
.SS ip (PAI)
This module is capable of listening on an UDP or TCP port and read messages or arrays, as well as sending data to remote hosts.
A message is created for each received packet and a timestamp is added.
If the received data does not match the specified data array, the packet is dropped.
.PP
If an instance is configured to wait for this module before starting, the we will set up any listening sockets before the
waiting instance is started.
.PP
The following configuration parameters are available in the
.B ip
module:
.PP
.Bl -tag -width -indent
.It ip_udp_port=LISTEN PORT
.It ip_tcp_port=LISTEN PORT
Port to listen on on udp or tcp. Udp  is also source port for outbound messages. Range is 1-65535, default value is 0 which means we don't listen.
If left unspecified, no listening takes place.

.It ip_input_types=ARRAY DEFINITION
Specification of expected data to receive from remote. See
.Xr rrr_post(1)
for the syntax. 
To receive RRR messages, set the definition to
.B msg
and set
.B ip_extract_rrr_messages
to
.B yes.
Array data will be read from all open connections, both for accepted connections (on the listening port) and for outgoing connections.
Array data on UDP will only be read if an UDP listening port is set.

.It ip_strip_array_separators={yes|no}
If set to yes, any array fields of the
.B sep
type is stripped out before RRR array messages are created. Defaults to no.  

.It ip_extract_rrr_messages={yes|no}
Extract any RRR messages from the received data (if specified in ip_input_types) and save them in the buffer for other modules to pick up.
Causes any other data in the received arrays to be dropped.
If set to yes and no message field is specified in the array definition, an error will be produced.
Defaults to no.

.It ip_max_message_size=BYTES
Maximum size of a message when reading. This should be set to prevent messages with missing delimeters to fill up memory.
A value of 0 means unlimited message size.
Defaults to 4096.

.It ip_default_topic=MQTT-TOPIC
An optional MQTT topic to set on the generated messages.

.It ip_accept_topic=TOPIC
If set, and when a new incoming TCP connection is established, a message is generated.
The generated message will be an empty data message of type GET.
If left unset, no messages will be generated until actual data is received.

.It ip_sync_byte_by_byte={yes|no}
If array parsing fails according to definition, keep skipping one byte forward in the stream until a match is found.
Defaults to no, which means to only sync on boundaries of incoming messages.

.It ip_send_rrr_message={yes|no}
If set to yes, complete RRR messages encoded for network will be sent.
If set to no or left unset, messages with arrays will have their array packed and sent, and messages with other data will simply have their contents sent as is.

.It ip_preserve_order={yes|no}
Attempt to always send messages in order according to when they first arrived in the IP module.
If messages time out before they are sent, order is guaranteed for the remaining messages in the queue.
To ensure order in all situations, the parameter
.B ip_persistent_timeout_ms
should not be zero and
.B ip_send_multiple_per_connection
should be 'yes'.
Order preservation can impact performance when destinations are unreachable due to sorting.
Defaults to no which means that order is not guaranteed when there are connection problems and retries.

.It ip_send_multiple_per_connection={yes|no}
If set to no, TCP connections are forced to be closed after a single message has been sent. Defaults to 'yes'.

.It ip_persistent_timeout_ms=MILLISECONDS
After a packet is sent or data is read on a TCP connection, keep the connection alive for the specifed amout of milliseconds or until more data is sent or received.
If set to 0, connections are closed promptly. Default value if left unset is 5000.
This parameter has no effect if
.B ip_send_multiple_per_connection
is 'no'.

.It ip_close_grace_ms=MILLISECONDS
After a TCP connection has been closed, prevent new connections to the same destination for the specified amount of milliseconds.
This prevents "ghost connections" in some situations where a host will accept a new connection immediately after another one has been closed,
even though the application on the host is not actually ready to accept any data.
May be set to zero, defaults to 5 milliseconds.

.It ip_send_timeout=SECONDS
If messages are not successfully sent within this time, perform the action specified in
.B ip_timeout_action.
Default is no timeout (same as 0).

.It ip_smart_timeout={yes|no}
If set to yes and a message is successfully sent, reset the timeout counter for all other unsent messages destined for the same host, port and protocol currently in the queue.
If set to no, unsent messages will time out according to the current send timeout regardless of whether other messages to the same destination have been sent or not in the meantime.
Defaults to no. 

.It ip_timeout_action={retry|drop|return}
What do do when a message times out after being undeliverable. In case of
.B retry,
keep trying indefinitely (default).
.B drop
will cause the message to be dropped, and
.B return
will put the message into output queue for readers to pick up. The latter is useful if an application for instance wishes to change
the destination address if the target host is unreachable, and possibly log errors. If
.B retry
is used, then
.B ip_send_timeout
must be set to zero or left undefined. 

.It ip_graylist_timeout_ms=MILLISECONDS
If a TCP destination is unreachable, add it to the graylist and retry only after the specified  number of milliseconds has passed.
Defaults to 100 ms. A value of zero disables graylisting, and causes a high rate of connection attempts to unreachable destinations.
If graylisting is used in while
.B ip_preserve_order
is also enabled, messages waiting to be sent to a graylisted host may temporarily prevent messages to other hosts from being sent.

.It ip_ttl_seconds=SECONDS
Check the creation timestamp of messages and drop them if they are or become older than the specified amount of seconds.
The TTL check is not the same as the send timeout, it does not respect
.B ip_timeout_action
nor
.B ip_smart_timeout.
TTL expiration also applies to partially sent messages.
Defaults to 0 which means that TTL check is disabled.   
 
.It ip_target_host=HOST
.It ip_target_port=PORT
.It ip_target_protocol=PROTOCOL
Default target host, port and protocol for messages from other modules which do not contain address information.
If left unset and we recevie messages which do not contain address information, the messages are dropped
and warning messages are produced. Protocol may be udp or tcp, defaults to udp.

.It ip_force_target={yes|no}
Use the specified target host and port even if messages contain other address information. Default is no.

.It ip_array_send_tags=tag1[,tag2[,...]]
Look for the defined tags in array messages from other modules, and send these concatenated together to remote.
If this option is specified and a received message is not an array or does not have all of the tags defined,
the message is dropped and an error message is produced.
If this option is left unspecified, all values from arrays are sent, and messages which are not arrays will have their raw data sent if any.

.El
.PP
.SS exploder (PA)
The exploder takes individual values from array messages and creates individual messages for each value.
.PP
.Bl -tag -width -indent
.It exploder_non_array_passthrough={yes|no}
If set to 'yes' and a non-array message is received, the message is passed through without modification.
If set to 'no' or left unset, non-array messages will be dropped.

.It exploder_original_passthrough={yes|no}
If set to 'yes', all original array messages are passed through.
If set to 'no' or left unset, the original messages are dropped.

.It exploder_preserve_timestamp={yes|no}
If set to 'yes', the timestamp from the original message will be used in any new messages.
If set to 'no' or left unset, the current time will be used for new messages.
In any case, any messages generated from a single message will have the same timestamp and the timestamp of the original message will not be modified.

.It exploder_preserve_topic={yes|no}
If set to 'yes', any topic from the original message will be used when the topics for new messages are created.
If set no 'no' or left unset, the topic will not be used.

.It exploder_topic=MQTT-TOPIC
Sets an optional static topic for new messages. If
.B exploder_preserve_topic
is 'yes', this topic specified will be appended to the original topic. No extra slashes will be added.

.It exploder_topic_append_tag={yes|no}
If set to yes, the tag of each value will be appended to topic of the generated messages.
The prefix to which the tag is added depends upon the configuration of options
.B exploder_preserve_topic
and
.B exploder_topic.
If none of those options are use, the tag will become the whole topic.
If set to 'no', the tag will not be appended to the message topic.

.El

.SS mangler (PA)
The mangler takes values from RRR arrays and converts them to different types. One RRR message with
converted values is generated for every received RRR message. Non-RRR array messages are by default
dropped.
.PP
.Bl -tag -width -indent
.It mangler_topic=MQTT-TOPIC
If set, the specified topic is set on all outgoing messages.
If left unset, any topic from the original messages is used.

.It mangler_clear_tags=TAG[,TAG...]
Values in input arrays which match one of the specified tags are deleted.
The deletion is performed prior to any conversion.
Optional parameter.

.It mangler_conversions={h2str|h2vain|blob2str|blob2blob|blob2hex|str2str|str2blob|str2h|msg2blob|hchar2str}[,...]
A comma separated list of conversion methods which provides a conversion recipe.
For every value of input arrays, all conversions are applied from left to right.
If a conversion fails or is not possible, it is skipped and the next method is attempted.

For instance if
.B h2str,str2h
is specifed, any numeric values are converted to strings and then back again.
Should the input array contain any string values, these will fail the first conversion,
but the second conversion will convert them to to numbers. A recipe like
.B str2h
would give the same result in which case any numbers would fail to convert and would
be left as numbers in the output.

Debuglevel 4 will generate step-by-step information during conversion, and debuglevel 2 will
cause the resulting arrays to be dumped (both of these combines to debuglevel 6).

By default,
.B str
values will be quoted using double quotes when exported in modules like
.B ip (PAI)
and
.B mqttclient (PA)
to allow separation.
If strings instead are converted to blobs using
.B str2blob,
they will be exported without quotes.

Refer to the
.B CONVERSION METHODS
section for descriptions of all conversions and type compatibility.

If this parameter is not set, no conversion is performed.

.It mangler_non_array_passthrough={yes|no}
If set to 'yes', non RRR-array messages are passed through to readers. Defaults to 'no' which will cause
such messages to be dropped.

.It mangler_convert_tolerant_blobs={yes|no}
If set to 'yes', any types compatible with the
.B blob
type will be accepted in any
.B blob2*
conversions. The conversion method
.B blob2blob
will have no effect unless this parameter is used.
Defaults to 'no' which means that only values of the excact type
.B blob
are accepted.

.It mangler_convert_tolerant_strings={yes|no}
If set to 'yes', any types compatible with the
.B str
type will be accepted in any
.B str2*
conversions. The conversion method
.B str2str
will have no effect unless this parameter is used.
Defaults to 'no' which means that only values of the excact type
.B str
are accepted.
.El

.SS buffer (P)
The buffer collects all messages from all senders and wait for them to be collected by other instances.
.PP
.Bl -tag -width -indent
.It buffer_ttl_seconds=SECONDS
Any message received with timestamp older than the specified amount of seconds will be dropped. Useful in situations
where messages circulate between modules.
.El
.SS ipclient (PI)
The ipclient module collects any messages from senders and sends them over the network to another 
.B RRR
environment's ipclient module using UDP. It may also accept connections from other clients and receive data,
or a combination of these. An underlying UDP stream protocol ensures single delivery of
all messages (similar design as MQTT QOS2), and messages are checksummed with a CRC32 algorithm.
.PP
.B ipclient is not secure in any way and must only be used on closed networks!
.PP
After an ipclient instance has connected to a remote ipclient, the remote will accept packets, and the connection
persists even if the connecting clients IP-address changes unless specified otherwise in the configuration.
.PP
Please note that ipclient is not designed to receive connections and packets from arbitary remote hosts.
If a remote sends packets and does not complete the acknowledgement handshakes, the packets will persist in memory.
.PP
If a remote host becomes unavailable for a longer period of time, unfinished acknowledgement handshakes
are re-initiated when it becomes available again, even if it has been re-started in the mean time.
.PP
ipclient will not accept incoming connections from other clients unless explicitly told to in the configuration file.
.PP
The following configuraton parameters are available in the
.B ipclient
module:
.PP
.Bl -tag -width -indent
.It ipclient_client_number=NUMBER
Each ipclient instance in a set of instances which communicate together must have a unique ID number in the range 1-4294967295.
If you have two instances running, set one of them to 1 and the other one to 2.

.It ipclient_default_remote=REMOTE NAME OR ADDRESS
The name or address of the client which we send packets without address information to.

.It ipclient_default_remote_port=PORT NUMBER
The port number of the default remote, defaults to 5555.

.It ipclient_src_port=PORT NUMBER
Source port used for sending and receiving packtes, defaults to 5555.

.It ipclient_listen={yes|no}
Accept incoming connections if set to yes. Default is no.

.It ipclient_ipv4_only={yes|no}
If set to yes, start IPv4 networking only. If left unset or set to no, IPv6 will be attempted first, and IPv4
will only be attemted if IPv6 fails.
If IPv6 succeeds, both IPv4 and IPv6 might actually be active depending on the operating system.

.It ipclient_disallow_remote_ip_swap={yes|no}
If yes and a remote changes its IP-address, RRR must restart before the new address can be accepted. Default is no. 
.El
.SS modbus (PA)
This module implements a modbus client supporting the functions
.B Read Coils (0x01), Read Discrete Inputs (0x02), Read Holding Registers (0x03), Read Input Registers (0x04), Write Single Register (0x06)
and
.B Write Multiple Registers (0x10)
.PP
The module is controlled using array command messages from sender instances, and there are no configuration parameters.
.PP
When a command is received, a connection is established with the specified modbus server and polling starts.
The command may be repeated at a specified interval, and stops when an equal command has not been received for two seconds.
.PP
The interval for a command may be changed by passing a command message with all other parameters being equal as another active command.
.PP
If different commands are used on the same server, they will share connection.
.PP
Please refer to the
.B Modbus Application Protocol
for details on the different modbus commands and responses.
.PP
The following array fields may be used in the command messages:
.PP
.Bl -tag -width -indent
.It modbus_server
The IP address of the modbus server to use. If not given,
.B localhost
is used. The maximum length of this field is 255 characters.
.It modbus_port
The port on the modbus server. If not given,
.B 502
is used.
.It modbus_response_topic
If given, any messages generated as a result of the command will have this topic set.
.It modbus_function_code
The modbus command to send, the commands
.B Read Coils (0x01), Read Discrete Inputs (0x02), Read Holding Registers (0x03), Read Input Registers (0x04), Write Single Register (0x06), Write Multiple Registers (0x10)
are supported. If not given,
.B 0x01
is used.
The function code must be stored in the array field in decimal form.
.It modbus_starting_address
The starting address for applicable commands. Defaults to 0, and must be in the range 0 - 65535.
.It modbus_quantity
For
.B Read Coils (0x01), Read Discrete Inputs (0x02)
quantity defaults to 8 and must be in the range 1 - 2000.
.br
For
.B Read Holding Registers (0x03), Read Input Registers (0x04)
quantity defaults to 1 and must the in the range 1 - 125.
.br
For
.B Write Multiple Registers (0x10)
quantity defaults to 1 and must the in the range 1 - 123.
.br
For any other function code quantity is not required and will be ignored if present.
.It modbus_contents
The raw data to write in
.B Write Single Register (0x06)
and
.B Write Multiple Registers (0x10).
.It modbus_interval_ms
If given, the command is repeated at the given interval for two seconds. Defaults to 0 which means that repeat is not performed.
.El
.PP
The following response messages and array fields are generated as a result of the modbus server
responding to commands, and these must be read by reader instances.
.PP
Data fields are in big endian where applicable (it is not manipulated in any way by the modbus module),
and they correspond to fields given in the protocol standard.
.PP
.Bl -tag -width "a" -indent
.It Error
.LI
.B modbus_server, modbus_port, modbus_function_code, modbus_exception_code
.It Read Coils (0x01), Read Discrete Inputs (0x02)
.LI
.B modbus_server, modbus_port, modbus_function_code, modbus_bytes, modbus_status
.It Read Holding Registers (0x03), Read Input Registers (0x04)
.LI
.B modbus_server, modbus_port, modbus_function_code, modbus_bytes, modbus_contents
.It Write Single Register (0x06)
.LI
.B modbus_server, modbus_port, modbus_function_code, modbus_starting_address, modbus_contents
.It Write Multiple Registers (0x10)
.LI
.B modbus_server, modbus_port, modbus_function_code, modbus_starting_address
.El
.PP
The array fields have the following contents:
.PP
.Bl -tag -width -indent
.It modbus_function_code
A one byte unsigned integer indicating a function code.
.It modbus_exception_code
A one byte unsigned integer indicating an exception code.
.It modbus_bytes
A one byte unsigned integer indicating the size of a data field.
.It modbus_status
A blob containing response data from a 
.B Read Coils (0x01) 
or 
.B Read Discrete Inputs (0x02) 
response of a length indicated by
.B modbus_bytes.
.It modbus_starting_address
An unsigned integer containing the starting address field returned in a response from a
.B  Write Single Register (0x06)
or
.B Write Multiple Registers (0x10)
response.
.It modbus_contents
For 
.B Read Holding Registers (0x03), Read Input Registers (0x04)
a blob containing response data from of a length indicated by
.B modbus_bytes.
.br
For 
.B Write Single Register (0x06)
a blob containing response data of length 2.
.B 
.El
.PP
.SS python3 (PAI)
This module can send messages to a custom python program and read them back.
All messages read from the senders are sent to the python program to the process function specified.
A read-only source function may also be specified if the python program should only generate messages by itself and not receive any.
It is possible to specify both source- and process-functions at the same time.
Functions should return 0 on success and put any messages into the result class provided in the argument.
If something goes wrong, the functions can return 1 or raise an exception which makes RRR stop all running instances and restart.
.PP
The RRR module should be imported by the custom python program, but is in only available when the python script is called from RRR.
.PP
The following configuration parameters are available in the
.B python3
module:
.PP
.Bl -tag -width -indent
.It python3_module=MODULE NAME
The module name for the python3 program to be executed. Imported by 'from MODULE NAME import *'

.It python3_module_path=MODULE NAME
An extra path in which to search for the module.

.It python3_source_function=FUNCTION NAME
The name of the source function in the python program which we read from continously.

.It python3_process_function=FUNCTION NAME
The name of the processing function in the python program which we send packets from other modules to. We also read any messages sent back.

.It python3_config_function=FUNCTION NAME
The name of the function in the python program to which we send settings form the configuration file.
All settings defined inside the python block in the configuration file are sent in here.

.It CUSTOM SETTING=VALUE
Any number of custom settings for the python program may be set as needed.
.El
.PP
Refer to the
.B cmodule
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of the following parameters:
.PP
.Bl -tag -width -indent
.It python3_workers=UNSIGNED INTEGER
.It python3_source_interval_ms=MILLISECONDS
.It python3_log_prefix=PREFIX
.It python3_drop_on_error={yes|no}
.El
.PP
Below follows an example python message processing and generating program. A socket is used to
post messages. The process and source functions have their own environments, and they will not
share any global variables set by the config function. The config function is called first in
the process environment, then in the source environment.
.PP
.EX
from rrr_helper import *
import time

my_global_variable = ""

def config(rrr_config : config):
	global my_global_variable

	# retrieve a custom setting from the configuration file. The get()
	# will update the "was-used" flag in the setting which stops a
	# warning from being printed.
	print ("Received configuration parameters")
	my_global_variable = config.get("my_global_variable")

	return True

def process(socket : rrr_socket, message: rrr_message, method: str):
	if (method is None):
		print("No method given to python3 processor function\n")
	else:
		print("Method given to processor function is " + method + "\n")

	# Return False if something is wrong
	if my_global_variable == "":
		print("Error: configuration failure\n")
		return False
		
	# modify the retrieved message as needed
	message.timestamp = message.timestamp + 1
	
	# queue the message to be sent back (optional) for python to give to readers
	socket.send(message)
	
	return True

def source(socket : rrr_socket, message : rrr_message):
	# Set an array value in the template message
    my_array_value = rrr_array_value()
    my_array_value.set_tag("my_tag")
    my_array_value.set(0, "my_value")

    my_array = rrr_array()
    my_array.append(my_array_value)

    message.set_array(my_array)

	# queue the message to be sent back (optional) for python to give to readers
	# skip this step if the message are not to be sent, it is then simply discarded
	# may be called multiple times with the same message
	socket.send(message)
	
	# sleep to limit output rate
	time.sleep(1)

	return True
	
.EE
More details about Python in 
.Xr rrr_python3(5)
.PP
.SS perl5 (PAI)
The perl5 module makes it possible to process and generate messages in a custom 
perl script. The first and only argument to the source- and process-subs
is the RRR message in the form of an object/hash reference of type
.B rrr_message
with different parameters which may be modified as needed. To pass the message back to RRR, the
.B $message->send()
is called. If the message should not be passed on, simply skip
the call to this method. The method may be called multiple times if required.
.PP
It is not possible to create new
.B rrr_message
objects from within the perl script. To send multiple messages in a single subroutine call,
the object passed in must be re-used. IP-, array- and data information in the message may be
cleared as needed when the message object is re-used.
.PP
It is possible to work with RRR array messages in the Perl script. This is done
through calling dedicated functions on the
.B rrr_message
object received by source and process functions. The functions available are listed in the example scripts with comments.
More details about types are found in 
.Xr rrr_post(1)
.PP
The following configuration parameters are available in the
.B perl5
module:
.PP
.Bl -tag -width -indent
.It perl5_file=FILENAME
Path and filename of the perl script to use. The script is run once when the program starts,
which means that code may be added outside the three subroutines mentioned below.

.It perl5_source_sub=SUBROUTINE NAME
Optional name of a subroutine which receives an rrr::rrr_helper::rrr_message object and modifies
it to generate a new message. Called at specified interval.

.It perl5_process_sub=SUBROUTINE NAME
Optional name of a subroutine which receives an rrr::rrr_helper::rrr_message object from the senders
of the current instance. The message may be modified or left alone.

.It perl5_config_sub=SUBROUTINE NAME
Optional name of a subroutine which receives an rrr::rrr_helper::rrr_settings object when the program
is started. Any settings from the instance definition in the configuration file can be read from
this object, also custom settings. Settings may also be modified and new settings can be added. The
settings object may also be stored in the script to be read from or modified from the source- and 
generate-subroutines.

.It CUSTOM SETTING=VALUE
Any number of custom settings for the Perl script may be set as needed.
.El
.PP
Refer to the
.B cmodule
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of the following parameters:
.PP
.Bl -tag -width -indent
.It perl5_workers=UNSIGNED INTEGER
.It perl5_source_interval_ms=MILLISECONDS
.It perl5_log_prefix=PREFIX
.It perl5_drop_on_error={yes|no}
.El
.PP
.B NOTE:
Any modified settings will currently not be visible in the perl5 RRR module, only in the perl5 script.
.PP
There must always be either a source- or process subroutine specified, or both. If a process subroutine
is specified, there must also be at least one sender specified.
.PP
If a Perl instance receives messages from an IP-capable module, like
.B ip or httpserver,
the address information of the original sender of a message is accessible in the
.B rrr_message
object. Other IP-capable modules may
then use this information if they read data from the Perl instance, for example if you wish to use
a Perl script to generate a reply message to some remote host.
The values
.B $message->{'ip_addr'}
and
.B $message->{'ip_addr_len'}
are to be found in the message hash. The values are filled with data from
.B struct sockaddr
and
.B socklen_t
which is provided by the operating system. These two values may be saved and re-used in later messages,
or they may be modified if you know how to do that (not documented here).
In addition,
.B $message->{'ip_so_type'}
can be either "udp" or "tcp" to describe a protocol type. Some modules may use this parameter. It can also be empty.
.PP
The IP information in a message can also be accessed and modified through helper functions. IPv4 and IPv6 both work
with these transparently.
.PP
.Bl -tag -width -indent
.It my ($ip, $port) = $message->ip_get();
Get IP (as text) and port from the message. Returns undefined if there is no IP information in the message.

.It $message->ip_set($ip, $port);
Set IP and port in a message. The $ip is in string representation (like 2a0a::1 or 4.4.4.4). Returns 1 on success and 0 on failure.

.It $message->ip_clear();
Delete IP information from a message. Always returns 1.
.El
.PP
The following additional parameters are available in the
.B rrr_message
object:
.PP
.Bl -tag -width -indent
.It $message->{'topic'}
The MQTT topic of the messsage.

.It $message->{'timestamp'}
The timestamp of the message.

.It $message->{'data'}
The raw data of the message (ignored when array is being used). Updates to the message array will not affect this field, but data
will be cleared if the message is sent with array fields set.

.It $message->{'data_length'}
The length of the data.

.It $message->{'type_and_class'}
Type and class of message, for internal use.
.El
.PP
If the
.B rrr_message
object contains an array, helper functions must be used to access these. A non-array message will
be treated as an array message if fields are added to it, and any data set in the message will be ignored when the message is sent.
.PP
The following functions are available for array field manipulation:
.PP
.Bl -tag -width -indent
.It $message->clear_array()
Clears all array fields, the message becomes a non-array message.

.It $message->push_tag_blob(tag, data, size)
Pushes a blob type. Caller must ensure that the data hase the specified size or more.

.It $message->push_tag_str(tag, string)
Pushes a string type.

.It $message->push_tag_h(tag, number)
Pushes a 64-bit integer. If the given number is unsigned, it will be stored as unsigned 64-bit in the array, otherwise it will be signed 64-bit.

.It $message->push_tag_fixp(tag, fixed_pointer)
Pushes an RRR fixed pointer type. If a string is given, string notation like
.B /^(10#|16#|)-?\\d+\\.\\d+$/
is assumed.  If a double is given, it is converted directly from double to fixed point. If the value given will be stored as a 64-bit integer internally in perl, native fixed point will be assumed (this is difficult to control in a script).

.It $message->push_tag(tag, value)
Push a value or on array of values. The type will be identified automatically. Array values are passed by using a reference like 
\\@my_array. If multiple values are given in an array, the must all have equal length.

.It $message->clear_tag(tag)
Deletes all array positions with the specified tags

.It $message->set_tag_blob(tag, data, size)
.It $message->set_tag_str(tag, string)
.It $message->set_tag_h(tag, values)
.It $message->set_tag_fixp(tag, fixed_point)
Using these functions is the same as calling clear_tag(tag) and then the corresponding push_tag function.

.It $message->get_tag_all(tag)
Retrieve all values corresponding to the specified tag. Returns a list with one or more values or undefined.

.It $message->get_position(position_number)
Retrieve the value at the specified position. Returns a list with one or more values or undefined.

.It $message->count_positions()
Count the number of positions in the array.

.It $message->get_tag_names()
Get all tag names from the array. Returns a list with zero or more values.
Always returns the same number of element as count_positions(). An empty string is used for positions without a tag.

.It $message->get_tag_counts()
Get the value count at each position of the message. Returns a list with zero or more values.
Always returns the same number of element as count_positions().
.El
.PP
The
.B rrr_debug
object can be used to print out debug messages just like RRR does internally. Use these instead of perl print functions
if you wish to have your program output messages in a tidy controlled fashion. There are three different functions in this class:
.PP
.Bl -tag -width -indent
.It $debug->msg(level, message)
Messages to this function are always printed prefixed with the specified loglevel (a number 0, 1, 2 etc.).

.It $debug->dbg(level, message)
Messages to this function are printed only if the specified loglevel (debuglevel) is active. If loglevel is 0 however,
the message is always printed.

.It $debug->err(message)
Messages to this function are always printed with loglevel 0 and to STDERR output. Do not overuse this as it might
cause broadcast messages on the system when RRR is run for instance by systemd. Error messages should usually be
printed using the
.B msg
function with loglevel 0.
.El
.PP
A variable must be blessed with the
.B rrr_debug
class to use the debug functions, look at the code below on how to do this. There are also commented out example
calls to message print functions. 
.PP
Below follows an example perl script.
.PP
.EX
#!/usr/bin/perl -w

package main;

use rrr::rrr_helper;
use rrr::rrr_helper::rrr_message;
use rrr::rrr_helper::rrr_settings;
use rrr::rrr_helper::rrr_debug;

my $debug = { };
bless $debug, rrr::rrr_helper::rrr_debug;

my $global_settings = undef;

sub config {
	# Get the rrr_settings-object. Has get(key) and set(key,value) methods.
	my $settings = shift;

	# If needed, save the settings object
	$global_settings = $settings;

	# Custom settings from the configuration file must be read to avoid warning messages
	# $debug->msg(1, "my_custom_setting is: " . $settings->get("my_custom_setting") . "\\n");

	# Set a custom setting
	$settings->set("my_new_setting", "5");

	# Return 1 for success and 0 for error
	return 1;
}

sub source {
	# Receive a newly generated template message
	my $message = shift;

	# Do some modifications
	$message->{'timestamp'} = $message->{'timestamp'} - $global_settings->get("my_custom_setting");

	# $debug->msg(1, "source:  new timestamp of message is: " . $message->{'timestamp'} . "\\n");

	# Pass on the new message
	$message->send();

	# Return 1 for success and 0 for error
	return 1;
}

sub process {
	# Get a message from senders of the perl5 instance
	my $message = shift;

	# Get any method set by method definition
	my $method = shift;

	if (defined $method) {
		print "Method given to processor function: $method\n";
	}
	else {
		print "No method given to processor function\n";
	}

	# Do some modifications to the message
	$message->{'timestamp'} = $message->{'timestamp'} - $global_settings->get("my_custom_setting");

	# $debug->msg(1, "process: new timestamp of message is: " . $message->{'timestamp'} . "\\n");

	# NOTE ! To understand how message arrays work, look in the MESSAGES section in the
	# man page of rrr.conf for a graphical representation (furter up if you're already in the man page).

	# An RRR array consits of several positions which each may have one or more value of a certiain
	# type and length. A position may or may not have an identification tag, and several positions
	# may have the same tag. An RRR message either contains raw data of some sort or an RRR array.

	# If array values are pushed to the message in a Perl5 script, any data in the message
	# will not be forwarded.

	# Push some values of dirrent types onto the message array. Since
	# we use the same tag name "tag" for many values, multiple values
	# with the same tag will exist within the array.
	$message->push_tag_blob ("tag", "blob", 4);
	$message->push_tag_str ("tag", "str");
	$message->push_tag_h ("tag", 666);
	$message->push_tag_fixp ("tag", 666);

	# Set some integer values
	my @my_integers = (1, 2, 3, 4);

	# The following function will accept both array values and other values.
	# If an array reference is passed, like here, the values will be added
	# to the same tag. If they are strings, their length -must- be equal.

	# If different length strings are required, push them into separate
	# tags like above. The RRR type is chosen based on the first value
	# in the array, type h (host endian integer) will be chosen here.
	$message->push_tag ("tag", \@my_integers);

	# This will get all matching values for a particular tag. Regardless
	# of wether duplicate tags have more than one element in the or not,
	# they will all be put into the same result array. Here, all the values
	# added above (four added one by one and four from the array) will
	# be put into @values_result which will end up having eight elements.
	my @values_result = $message->get_tag ("tag");

	# The set_* functions will delete all matching tag names from the array
	# and then push the new value. The type of any existing does not matter,
	# all tags with matching tag name in the array will be removed.
	$message->set_tag_blob ("tag", "blob", 4);
	$message->set_tag_str ("tag", "str");
	$message->set_tag_fixp ("tag", 666);
	$message->set_tag_h ("tag", 1);

	# It is allowed to have empty tag names, just use "" as tag
	$message->set_tag_h("", 0);

	# Since set_tag_h is the last value, the number '1' is the only
	# element in the array now with the tag "tag". The get_tag_all
	# function will otherwise retrieve all values at all matching tags.
	my @array_with_only_one_value = $message->get_tag_all ("tag");

	# It is possible to retrieve a particular element at a certain position
	# if the position of a value is known. Since we know there is a
	# number with the tag "tag" in the array, we can get the first element
	# returned.
	my $value = ($message->get_tag_all("tag"))[0];

	# These two functions returns arrays containing the tag names
	# at each array position, or the value count at each position. If
	# there is no tag name at a position, an empty "" value is returned.
	# All array position always has at least one element.
	print "Tag names: " . join(",", $message->get_tag_names ()) . "\n";
	print "Tag counts: " . join(",", $message->get_tag_counts ()) . "\n";

	# Get all values at a particular position
	print "Get a position: " . join (",", $message->get_position(0)) . "\n";
	print "Array position count: " . $message->count_positions() . "\n";

	# This will clear all values from the array which has the specified tag
	$message->clear_tag("tag");

	# This will clear all values from the array
	# $message->clear_array();

	# Pass on the modified message
	$message->send();

	# Return 1 for success and 0 for error
	return 1;
}
.EE
.SS lua (PAI)
The Lua module makes it possible to process and generate messages in a custom 
Lua script. The source function in the scripts receives an empty message object,
and the process function receives populated messages from another module.
Additional message objects may be created as well.

Messages may be passed on using the
.B send()
method on the message object.

The following configuration parameters are available in the
.B lua
module:

.Bl -tag -width -indent
.It lua_file=FILENAME
The file containing the Lua script to run. The script will be run once when the program starts, and global code outside of functions will be executed.
If multiple workers are used by setting the parameter
.B lua_workers,
the script will run once for each worker and global variables will not be accessible between different workers.

The functions must return a boolean value where true indicates success and false indicates failure.

.It lua_config_function=NAME
The function to call before sourcing and processing starts.

.It lua_source_function=NAME
The function to call regularely.
The source function receives an empty message object which may be populated with data.

.It lua_process_function=NAME
The function to call when a message from another module should be processed.
The process function receives a populated message object from another module.
If methods are used (without direct dispatch), the method name is passed as a string as the second argument.

.It lua_precision_loss_warnings={yes|no}
If set to yes or left unset, warnings will be printed if precision loss occurs when converting numbers to fixed point.

.It CUSTOM SETTING=VALUE
Any number of custom settings for the Lua script may be set as needed.
.El

Refer to the
.B cmodule
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of the following parameters:
.PP
.Bl -tag -width -indent
.It lua_workers=UNSIGNED INTEGER
.It lua_source_interval_ms=MILLISECONDS
.It lua_log_prefix=PREFIX
.It lua_drop_on_error={yes|no}
.El
.PP
There must always be either a source- or process function specified, or both. If a process function
is specified, there must also be at least one sender specified.
.PP
Logging, retrieval of configuration parameters and sending of messages is done through the
.PP
The Debug object, which is used to print debug and log messages, has the following functionallity:
.PP
.Bl -tag -width -indent
.It debug = RRR.Debug.new()
Create a new debug object. This is required before any messages can be printed.

.It debug:msg(level, message)
Messages to this function are always printed prefixed with the specified loglevel (a number 0, 1, 2 etc.).

.It debug:dbg(level, message)
Messages to this function are printed only if the specified loglevel (debuglevel) is active. If loglevel is 0 however, the message is always printed.

.It debug:err(message)
Messages to this function are always printed with loglevel 0 and to STDERR output. Do not overuse this as it might cause broadcast messages on the system when RRR is run for instance by systemd. Error messages should usually be printed using the msg function with loglevel 0.
.El
.PP
The Message object, which is used to modify and create RRR messages, has the following functionallity:
.PP
.Bl -tag -width -indent
.It message = RRR.Message.new()
Create a new message.

.It message:send()
Pass the message to reader instances.

.It message:ip_set(ip, port)
Set IP address parameters.

.It ip, port = message:ip_get()
Get IP address parameters (returns empty string for IP if no IP is set).

.It message:ip_clear()
Clear IP address parameters (same as calling ip_set("", 0)).

.It message:ip_so_type = "UDP"
Set or get IP protocol to UDP or TCP (string). May be empty.

.It message:topic = "TOPIC"
Set or get message topic (string). May be empty or otherwise a valid MQTT topic.

.It message:timestamp = 1696752424000000
Set or get message timestamp (integer) in microseconds. Not available for manipulation if Lua was built with less than 64 bit integers.

.It message:data = ""
Set or get message data. The data field is ignored if the message has any array fields set.

.It message:type = RRR.Message.MSG_TYPE_MSG
Set or get message type, use one of the constants from the Message object:
.sp

.Bl -tag -width "aa"
.It \(bu
RRR.Message.MSG_TYPE_MSG
.It \(bu
RRR.Message.MSG_TYPE_TAG
.It \(bu 
RRR.Message.MSG_TYPE_GET
.It \(bu 
RRR.Message.MSG_TYPE_PUT
.It \(bu
RRR.Message.MSG_TYPE_DEL
.El

.It message:class = RRR.Message.MSG_CLASS_DATA
Set or get message class.
Changing this field has no effect as ARRAY or DATA is implicitly set depending on whether
or not the message has array fields set.
Use one of the constants from the Message object:
.sp
.Bl -tag -width "aa"
.It \(bu
RRR.Message.MSG_CLASS_DATA
.It \(bu
RRR.Message.MSG_CLASS_ARRAY
.El

.It message:clear_array()
Remove any array fields, message becomes DATA type.

.It message:clear_tag("my_tag")
Clear any array fields with the given tag.

.El
.PP
All push and set functions accept arrays as well. The first element in the array
will determine the type of the value unless a type specific method is used.

Note that if an array is passed to set_tag or push_tag in which the first value
is a boolean, all values in the array will be converted to booleans which means
that all values apart from 'false' and 'nil' will be converted to 'true'.

Lua typically only supports 64 bit signed values, while RRR h type may hold 64 bit unsigned.
To push a large unsigned integer which does not fit in a Lua integer, pass the number as a
string to push_tag_h or set_tag_h.
.PP
.Bl -tag -width -indent
.It message:push_tag_str("my_tag", "my_value")
Push an array value of string type.

.It message:push_tag_blob("my_tag", "my_value")
Push an array value of blob type.

.It message:push_tag_h("my_tag", 1)
Push array value of type host (integer).

.It message:push_tag_fixp("my_tag", 3.5)
.It message:push_tag_fixp("my_tag", "3.5")
.It message:push_tag_fixp("my_tag", "16#a.cde")
Push array value of fixed pointer type.

.It message:push_tag("my_tag", 1)
Push a value with automatic type detection.
Depending on the type of the value, the following will happen:
.Bl -tag -width "aa" -indent
.It Decimal number
Will be converted to fixp unless precision loss occurs, in which case it will be converted to a string while also printing a warning message
.It Number without decimals
Will be converted to h (host endian integer signed or unsigned)
.It String
Will be converted to str
.It Nil
Will be converted to vain
.It Boolean
Will be converted to h (set to 1 or 0)
.El

.It set_tag_str("my_tag", "my_value")
.It set_tag_blob("my_tag", "my_value")
.It set_tag_h("my_tag", 1)
.It set_tag_fixp("my_tag", 3.5)
.It set_tag("my_tag", 1)
Set values (same as push functions, but any matching tags are cleared first).

.It message:get_position(position_number)
Retrieve the value at the specified position. Returns a list with one or more values or nil.

.It message:count_positions()
Count the number of positions in the array.

.It message:get_tag_names()
Get all tag names from the array. Returns a list with zero or more values.

.It message:get_tag_counts()
Get the value count at each position of the message. Returns a list with zero or more values.
.El
.PP
The Config object, which is used to retrieve settings from the RRR configuration file,
may not be instantiated but is received as argument to any specified configuration method.
It has the has the following functionallity:
.PP
.Bl -tag -width -indent
.It config:get(key)
Retrieve a setting from the configuration file. Returns a string or nil if the setting is not found.
.It config:set(key, value)
Set a setting in the configuration file. The setting will only be visible to the current Lua script.
.El
.PP
Below follows an example Lua script.
.PP
.EX
-- Create a debug object
local debug = RRR.Debug.new()

-- Create a configuration table
local my_config = { }

-- Configuration function
function config(config)
	-- Read configuration parameters and store them in the config table
	for _, key in ipairs({"param_a", "param_b", "param_c"}) do
		if not config:has(key) then
			debug:msg(0, "Configuration parameter '" .. key .. "' was not found")
			return false
		end
		my_config[key] = config:get(key)
	end

	-- Set a custom setting
	config:set("my_custom_setting", "5")

	-- Retrieve a custom setting
	debug:msg(1, "my_custom_setting is: " .. config:get("my_custom_setting"))

	return true
end

-- Process function
function process(message, method)
	-- Get any method set by method definition
	if method then
		debug:msg(1, "Method given to Lua processor function: " .. method)
	else
		debug:msg(1, "No method given to Lua processor function")
	end

	-- Print some information about the message
	debug:msg(1, "Processing a message\n")
	debug:msg(1, "- The timestamp of the message is: " .. message:timestamp .. "\n")
	debug:msg(1, "- The topic of the message is: " .. message:topic .. "\n")
	debug:msg(1, "- The message has " .. message:count_positions() .. " array positions\n")

	-- Do some modifications
	message:topic = message:topic .. "/" .. my_config["param_a"]

	-- Remove any array values
	message:clear_array()

	-- Set data in the message
	message:data = "Hello world"

	-- Pass on the modified message
	message:send()

	return true
end

-- Source function
function source(message)
	-- Do some modifications
	message.push_tag("my_param_a", my_config["param_a"])
	message.push_tag("my_param_b", my_config["param_b"])
	message.push_tag("my_param_c", my_config["param_c"])

	-- Pass on the new message
	message:send()

	return true
end






















.SS js (PAI)
The js module makes it possible to process and generate messages in a custom  JavaScript.

The following configuration parameters are available in the
.B js
module:

.Bl -tag -width -indent
.It js_file=FILENAME
The file containing the JavaScript to run. The script will be run once when the program starts, and global code outside of functions will be executed.
If multiple workers are used by setting the parameter
.B js_workers,
the script will run once for each worker and global variables will not be accessible between different workers.

.It js_module_name=NAME
Load the file given
.B js_file
as a module. This allows the usage of the
.B import
keyword to load other modules.
If not given, the file will be loaded as a plain script.

.It js_config_function=NAME
The function to call before sourcing and processing starts.

.It js_source_function=NAME
The function to call regularely.

.It js_process_function=NAME
The function to call when a message from another module should be processed.

.It CUSTOM SETTING=VALUE
Any number of custom settings for the JavaScript script may be set as needed.
.El

Refer to the
.B cmodule
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of the following parameters:
.PP
.Bl -tag -width -indent
.It js_workers=UNSIGNED INTEGER
.It js_source_interval_ms=MILLISECONDS
.It js_log_prefix=PREFIX
.It js_drop_on_error={yes|no}
.El

A scripts with all three function types defined may look like this:

.EX
let my_parameter = undefined;

function config(config) {
	// Read configuration parameter
	if (!config.has("my_parameter")) {
		throw "Configuration parameter 'my_parameter' was not found";
	}
	my_parameter = config.get("my_parameter");
}

function source(message) {
	// Send a new message from the source function
	console.log("Sourcing a message\n");
	message.send();
}

function process(message, method) {
	// Process a message from another module
	// and add the value previously retrieved
	// from the configuration file.

	if (method !== undefined) {
		console.log("Method given to JS processor function: " + method + "\n");
	}
	else {
		console.log("No method given to JS processor function\n");
	}

	console.log("Processing a message\n");
	message.push_tag("my_parameter", my_parameter);
	message.send();
}
.EE

The
.B config
function receives a Config object from which configuration parameters can be read.
Config objects cannot be created using the
.B new
operator.

The
.B source
and
.B process
functions both receive a Message object whenever called.
An empty Message object is passed to the
.B source
function.

Additional Message objects may be created using the
.B new
operator.

The Config and Message objects have the following members:

.EX
// Data type Config
{
  has: function(parameter){},   // Returns true if the parameter exists, and false otherwise
  get: function(parameter){}    // Returns the value of the configuration parameter
}

// Data type Message
{
  // Message header manipulation
  ip_addr: new ArrayBuffer(),    // Operating system raw IP address information (struct sockaddr)
  ip_so_type: "",                // Protocol, set to UDP or TCP. May also be empty.
  topic: "",                     // MQTT topic of the message
  timestamp: BigInt(0),          // The timestamp of the message in microseconds
  data: new ArrayBuffer(),       // The raw data of the message (ignored when arrays are used)
  type: MSG_TYPE_MSG,            // Message type. Alternatives are MSG, TAG, GET, PUT, DEL
  class: MSG_CLASS_DATA,         // Message class (immutable, automatically set to ARRAY if array is used)

  ip_set: function(ip, port){},             // Helper function to set adddress of ip_addr field
  ip_get: function(){ return [ip, port]; }, // Helper function to retrieve adddress of ip_addr field

  // Constants for the type field
  MSG_TYPE_MSG: 1,
  MSG_TYPE_TAG: 2,
  MSG_TYPE_GET: 3,
  MSG_TYPE_PUT: 4,
  MSG_TYPE_DEL: 5,

  // Constants for the class field
  MSG_CLASS_DATA:  1,
  MSG_CLASS_ARRAY: 11,

  // Array data manipulation. When tag argument is not given, value(s) without tag is assumed
  clear_array:     function(){},                  // Clear all array data
  clear_tag:       function(tag=null){},          // Clear all array values with the given tag
  push_tag_blob:   function(tag=null, data){},    // Push array value of type blob
  push_tag_str:    function(tag=null, data){},    // Push array value of type string
  push_tag_h:      function(tag=null, data){},    // Push array value of type host (integer)
  push_tag_fixp:   function(tag=null, data){},    // Push array value of type fixp (fixed pointer)
  push_tag_object: function(tag=null, data){},    // Push an object which will be converted to an string with JSON-representation of the object
  push_tag:        function(tag=null, data){},    // Push array value and identify type automatically
  set_tag:         function(tag=null, data){},    // Clear values with the given tag and push a new array value and identify type automatically
  get_tag_all:     function(tag=null){return [];},// Get array of values with the given tag
  send:            function(){}                   // Send the message to the output buffer for other instances to receive
}
.EE

When using
.B push_tag_object
, any resulting JSON must begin with either [ or {, and an exception will be thrown otherwise.
The function is thus less permissive than the default stringify function in JS.

If an object is added using
.B push_tag_object
and another instance of the
.B js
module accesses this value, the JSON will be parsed and de-serialized into the original object structure.
Modules not compatible with JSON strings will treat such values just as other strings.

The following special global Objects are available:

.EX
// Data type Console (accessed through global name console)
{
  log(message);                 // Log a message using debuglevel 7
  error(message);               // Log a message using debuglevel 0 (error)
  assert(assertion, message);   // Log a message using debuglevel 0 if assertion is false and crash program
  critical(message);            // Log a message using debuglevel 0 (error) and crash program
}

// Data type Timeout (run a scheduled function once). Syntax is shown. The
// timeout object need not be stored in a variable unless it might be required
// to run clear() at a later time. If the timeout is 0 milliseconds, the function
// will run immediately after the script returns. Any additional arguments will be
// passed to the function.

// Create a timeout
const timeout = new Timeout(function, timeout_ms = 0, arg1 = undefined, ...)

// Prevent the timeout from ever running (regret)
timeout.clear();

// Create an operating system object
const os = new OS();

// Retrieve the hostname of the host on which the script runs
const hostname = os.hostname();

.EE

.SS cmodule (P)
This module allows usage of custom cmodules (C-modules) in a simplified framework. To use this, a module must first be
written in the RRR source in the directory /src/cmodules/ and then compiled (just compile RRR as usual and
directions will be given). There is an example file with appropriate licenses in the cmodules directory
which may be used as a template for custom cmodules.
.PP
RRR will deal with communication with other modules and many other tasks, which makes it simpler to write a
cmodule than to write a native RRR module.
.PP
All custom cmodules will be run in separate forks.
.PP
The following confgiuration parameters are available in the
.B cmodule
module: 
.PP
.Bl -tag -width -indent
.It cmodule_name=NAME
The name of the cmodule. If the name is
.B dummy,
RRR will look for the module
.B dummy.so
and the source file for this module should be called
.B dummy.c.

.It cmodule_config_function=NAME
The function to which to pass configuration parameters, called at program startup. Optional.

.It cmodule_source_function=NAME
The function to which to call to source new messages. Optional, but at least one of source and processor must be set.

.It cmodule_process_function=NAME
The function to which to call to process messages from senders. Optional, but at least one of source and processor must be set.

.It cmodule_cleanup_function=NAME
The function to call before the program shuts down. Optional.

.It CUSTOM SETTING=VALUE
Any number of custom settings for the C-module may be set as needed.
.El
.PP
Refer to the
.B cmodule
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of the following parameters:
.PP
.Bl -tag -width -indent
.It cmodule_workers=UNSIGNED INTEGER
.It cmodule_source_interval_ms=MILLISECONDS
.It cmodule_log_prefix=PREFIX
.It cmodule_drop_on_error={yes|no}
.El
.PP
The source and process functions receives a new message which of they must manage the memory. The message must
either be passed on to other modules by calling
.B rrr_send_and_free(...)
or be freed (if the message is to be discarded) by calling
.B rrr_free(...).
A message, if it must be sent several times, may be duplicated by using.
.B rrr_message_duplicate(...).
.PP
Please refer to the source code on how these functions work. Some headers which
might be useful when working with for instance array messages are included in /src/cmodules/cmodule.h .
It is not a priority at this time to document these, but they are easy to use and usage examples are to
be found throughout the RRR source code (which is human- and machine readable).
.PP
Functions must return 0 on success and 1 if there are errors.  
.SS socket (SA)
The socket module listens on a UNIX socket for RRR messages or custom data records.
.PP
The following configuration parameters are available in the
.B socket
module:
.PP
.Bl -tag -width -indent
.It socket_path=FILENAME
Path and file name to use for the socket. The file cannot exist when the program starts.

.It socket_unlink_if_exists={yes|no}
If set to yes and the socket defined in `socket_path` exists when we start, unlink it. If set to no, we produce an error if
the socket exists. Defaults to no.

.It socket_default_topic=MQTT-TOPIC
An optional MQTT topic to set on the generated messages.

.It socket_receive_rrr_message={yes|no}
If set to 
.B yes
, complete RRR messages are expected to be received on the socket. No array definition is to be specified. 
.Xr rrr_post(1)
may generate such messages. If set to 
.B no
, an array definition must be specified, and RRR array messages will be produced from the received data. Defaults to no.

.It socket_input_types=ARRAY DEFINITION
Format of data received on the socket, see
.Xr rrr_post(1)
for syntax.

.It socket_sync_byte_by_byte={yes|no}
If array parsing fails according to definition, keep skipping one byte forward in the stream until a match is found.
Defaults to no, which means to only sync on boundaries of incoming messages.
.El
.SS httpserver (PAI)
This module accepts connections from HTTP clients, extracts data fields and saves them into RRR array messages for other modules to use.
The query string from the URI is parsed in all request types. Duplicate field names are allowed.

.B DO NOT USE
this HTTP server openly on the Internet. It has
.B NO PROTECTION MECHANISMS
against DoS attacks, flooding etc. There is also
.B NO AUTHENTICATION.
Use a server like Apache to run a public server.

The following request methods are supported which may or may not have a body according to standards:

.Bl -dash -offset indent -compact
.It
GET
.It
OPTIONS
.It
POST
.It
PUT
.It
PATCH
.It
HEAD
.It
DELETE
.El

Generated  messages will have the topic
.B httpserver/request/uuu
set, where
.B uuu
is a unique unsigned decimal number which increase by 1 for every received request.
Messages will not be generated for the 
.B OPTIONS
method, only default 204 responses will be sent to these requests.

For PUT, PATCH and POST request which have a body, value fields will be extracted from bodies with the following content types:

.Bl -dash -offset indent -compact
.It
multipart/form-data
.It
application/x-www-form-urlencoded
.It
application/json
.El

If other formats are to be parsed,
.B http_server_receive_full_request
can be used and the body can then be parsed by a script in the python3 or perl5 modules.

Structural fields set due to
.B http_server_receive_full_request
being active, fields from the URI and field from PUT/PATCH/POST data will all be added to the same array in the following pre-defined order.
Duplicate value field names are allowed.

.Bl -enum -offset indent -compact
.It
Structural fields
.It
Fields from request URI
.It
Fields from PUT/PATCH/POST data
.El

When receiving JSON data, one RRR array message will be generated for every JSON object containing bare associative values regardless of nesting.
In each of the messages, an additional value named
.B http_request_partials
describing the total number of messages for this request is placed at the beginning of the array followed by the structural fields and any fields from the URI before fields from the JSON object.
.PP
This module does not respond with any data by default.
If a request was successfully processed, a
.B 204 No Content
response is returned to the client. If there were any errors,
.B 400 Bad Request
or
.B 500 Internal Server Error
response may be returned.
If a response is expected to be generated by a sender instance of
.B httpserver, a
.B 504 Gateway Timeout
response will be generated if the response timeout is reached.
.PP
The following configuration parameters are available in the
.B httpserver
module:
.PP
.Bl -tag -width -indent
.It http_server_transport_type={tls|plain|both}
Listen with TLS mode, plaintext mode or both. Defaults to 'plain'.

.It http_server_port_tls=PORT
Port to use for TLS listening, defaults to 443.

.It http_server_port_plain=PORT
Port to use for plaintext listening, defaults to 80.

.It http_server_request_max_mb=MEGABYTES
Maximum size in megabytes for requests. A value of 0 indicates unlimited request size. Defaults to 10.

.It http_server_fields_accept=HTTP FIELD[->ARRAY TAG][,...]
Specify a comma separated list POST and GET fields to allow from clients. Fields not specified here are ignored unless
.B http_server_fields_accept_any
is set to 'yes'.
An optional array tag may be specified for each field if the field name should be translated when added to the RRR array message.
This parameter is optional.

.It http_server_fields_accept_any={yes|no}
Accept any field names from incoming requests. May not be used with
.B http_server_fields_accept. 
Defaults to 'no'.

.It http_server_no_body_parse={yes|no}
Disable any parsing and field extraction of the request body regardless of its content type.
Defaults to 'no'.

.It http_server_allow_empty_messages={yes|no}
Allow messages with no array values to be generated. This option also affects
.B http_server_receive_full_request.
If set to 'no' or left unset, messages will not be generated unless they would contain at least one array value.

.It http_server_receive_full_request={yes|no}
Get structural HTTP data from the request and add it to an RRR array message along with any fields. 
The following array values will be present in generated messages:
.sp
.Bl -tag -width -indent
.It http_method
Always present.
.It http_protocol
Always present with the value 1 or 2.
.It http_endpoint
Always present, given in uppercase letters.
.It http_body
Added if a body of non-zero length is present.
.It http_content_transfer_encoding
Added if the header value
.B content-transfer-encoding
is present in the header.
.It http_content_type
Added if the header value
.B content-type
is present in the header.
.It http_content_type_boundary
Added if
.B content-type
is present in the header and has the value 'multipart/form-data'.
.El
.sp
Note that if
.B http_server_allow_empty_messages
is active, no messages without body will be generated.

If set to 'no' or left unset, only fields from the HTTP request will be present in generated messages.

.It http_server_get_response_from_senders={yes|no}
If this option is set to 'yes', a sender instance of
.B httpserver
is expected to generate HTTP responses. Implies
.B http_server_receive_full_request=yes.

An instance which receives RRR messages from
.B httpserver
containing requests may generate responses in an RRR array message with the following fields of which all are optional:
.sp
.Bl -tag -width -indent
.It http_response_code
The response code and text to use in the response, defaults to 200 or 204 depending on whether or not any data is present
(httpserver will implicitly force the usage of a 200 response if the status is 204 and a body is present).
Must be a value >= 100 and <= 599.
200 or 204 will be selected silently if the provided code is out of this range.
.sp
.It http_content_type
The content type to use for the response. If it is defined but is an empty string, no content type header will be sent.
If not defined, the content type sent will depend on the type of the
.B http_body
field.
In any case, a content type header will not be sent if there is no response body.

.It http_body
The response body to send. The content type set in the response header, unless specified explititly in 
.B http_content_type,
depends on the type of this field:
.sp
.Bl -tag -width -indent
.It blob
application/octet-stream
.It msg
application/rrr-message
.It str
text/plain (also used by other types convertible to strings (numbers etc.))
.It vain
No response body generated
.El
.sp
.El

Response messages from another instance may also be a plain data message in which the data of this message will be treated the same way as data from the
.B http_body
field with blob type. The other fields will in this case get default values per above rules.

If set to 'no' or left unset,
.B httpserver
will generate default responses.

.It http_server_test_page_default_response={yes|no}
Send a simple test HTML page with the RRR logo whenever an empty default response otherwise would have been sent. Defaults to 'no'.

.It http_server_favicon_not_found_response={yes|no}
Always respond with 404 Not Found to requests with
.B /favicon.ico
endpoint. If set to 'no' or left unset, these requests are treated as any other.

.It http_server_response_timeout=MILLISECONDS
How long to wait for a response from senders before timing out and generating a
.B 504 Gateway Timeout
response. Defaults to 2000.

.It http_server_allow_origin_header=STRING
If defined,
.B httpserver
will send an
.B Access-Control-Allow-Origin
header with the given string in all response headers.
The header is mainly used by web browsers, look online for documentation on what it does.
Using the header, in particualar setting it to * (which means to allow all origins), may have
.B security implications.

.It http_server_cache_control_header=STRING
If defined,
.B httpserver
will send a
.B Cache-Control
header with the given string in all response headers.

.It http_server_websocket_topic_filters=MQTT TOPIC FILTER[,MQTT TOPIC FILTER,...]
If specified, connection upgrades websocket version 13 will be supported if the endpoint of the URL received from the client matches
with one or more of the specified topic filters.
The full URL except from the first / of the URL and the query string (after ? inclusive) is used as the MQTT topic.

By default, the text from websocket text frames will be put into RRR messages for other modules to pick up.
These messages will have a topic identifying the current connection, like
.B httpserver/websocket/uuu/TOPIC
where
.B uuu
is a unique ID identifying the websocket connection and
.B TOPIC
is the topic set in the URL endpoint.
The unique ID will be the same as for any HTTP message received previously on the same connection, which might or might not have caused
RRR messages to be generated depending on other configuration options.
By default, no websocket connection upgrades are accepted.

If
.B httpserver
receives messages from it's senders beginning with
.B httpserver/websocket/uuu,
these messages will be forwarded to the active websocket connection with the ID specified in
.B uuu
as text frames.
Messages received in httpserver with IDs not matching any active connections will be dropped.

.It http_server_accept_websocket_binary={yes|no}
Allow binary websocket frames. Data from such frames are put into plain RRR messages.
If set to 'no' or left unset, received binary frames will be ignored. 

.It http_server_receive_websocket_rrr_message={yes|no}
If set to 'yes' and websocket frames of binary type is received, these are interpreted as being RRR messages of any type.
RRR message validation and endian conversion will be performed, and the socket will be closed if this fails.
Implies
.B http_server_accept_websocket_binary=yes.

Messages of text type are not affected by this parameter.

If set to 'no' or left unset, binary messages are either ignored or received as-is depending on the value of
.B http_server_accept_websocket_binary.

.It http_server_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional.
.El
.PP
With default configuration, having no parameters specified, no RRR messages will be generated for received requests.
.PP
The following protocols are supported by
.B httpserver,
and may be used at the clients discretion:
.PP
\(bu HTTP/1.0 and HTTP/1.1 where the latter implies keepalive connection
\(bu Websocket through upgrade from HTTP/1.1
\(bu HTTP/2 through upgrade from HTTP/1.1
\(bu HTTP/2 plain mode using HTTP/2 magic
\(bu HTTP/2 negotiated using TLS/ALPN
.PP
.SS httpclient (PAI)
This module takes RRR messages from other modules and sends them to an HTTP server. Array values in received messages
may be sent as HTTP form fields. GET and POST are supported using either HTTP or HTTPS. This module does not
use any data sent from the server, any data received is ignored.
.PP
The following configuration parameters are available in the
.B httpclient
module:
.PP
.Bl -tag -width -indent
.It http_server=SERVER OR IP
.It http_port=PORT
Server and port to send data to, defaults to 'localhost' and the default port depends on the
chosen transport type (TLS/Plain).
.B httpclient
will follow any redirects from the server, also to other servers.
To disallow redirection, use the
.B http_max_redirects
parameter.
 
.It http_endpoint=ENDPOINT
The endpoint to request from the server, e.g.
.B /index.php.
If the server responds with a redirect, this new endpoint will be used.
It is possible to specify a query string in the endpoint, like
.B /index.php?a=1&b=2.
If the server responds with redirect, this query string will not be included in the folling request.
If GET method is used, any query values from RRR messages will be appended to the query string, also if there are redirects.
.B httpclient
will detect whether a query string already exists in the URL and prefix the first parameter with either ? or &.
Defaults to
.B /.
Any provided endpoint by means of this parameter or otherwise must contain only characters which are valid for URIs;
If for instance spaces are to be used in an endpoint, these must be encoded as %20.

.It http_transport_type={tls|plain|both}
If transport type is set to 'plain' or 'tls', HTTP or HTTPS will be
.B enforced,
which means that redirects fro the server to a different transport type than the chosen one will be rejected.
Use 'both' or leave unspecified for automatic transport type.

.It http_response_max_mb=MEGABYTES
Maximum size in megabytes for responses. A value of 0 indicates unlimited response size. Defaults to 10.

.It http_version_10={yes|no}
If set to yes, protocol version HTTP/1.0 is used when sending requests and upgrade to HTTP/2 will not be requested, also not using TLS ALPN.
If set to no or left unspecified, HTTP/1.1 will be used and upgrade to HTTP/2 will be requested to the server with all queries.

In case of an upgrade request, the server will either allow upgrade to HTTP/2 and continue using that or simply respond with HTTP/1.1 or HTTP/1.0.

Some HTTP servers always respond with either version HTTP/1.1 or HTTP/1.0 regardless of which version the client used in the request.
If the server responds with HTTP/1.0, the connection will be closed just after a response have been received.
If the server responds with HTTP/1.1, the connection will be kept alive for a few seconds before being closed if no other requests are to be sent

.It http_method={get|put|post|head|delete|options}
Which method to use when sending data to the server. Defaults to
.B get.

.It http_format={urlencoded|multipart|json|raw}
Control which body format to use for PUT, PATCH and POST requests. If the
.B raw
mode is set, messages which do not contain a body (specified in the tag named in
.B http_body_tag
) will trigger an error as they are processed.
An appropriate Content-Type header will be sent according to standards.
Messages with a body are otherwise not affected by this parameter.
Defaults to 'urlencoded'.

\(bu If
.B get
is used, any fields will be appended to the endpoint after a questionmark ?. GET requests have no body.
.br
\(bu If
.B post_urlencoded
is used, any fields will be made into a query string and sent in the POST body of type 'application/x-www-form-urlencoded'.
.br
\(bu If
.B post_multipart
is used, any fields will be made into separate mime parts and sent in the POST body of type 'multipart/form-data'. This method is recommended for large data fields.

.It http_endpoint_tag=ARRAY TAG
.It http_method_tag=ARRAY TAG
.It http_server_tag=ARRAY TAG
.It http_port_tag=ARRAY TAG
.It http_body_tag=ARRAY TAG
.It http_format_tag=ARRAY TAG
.It http_content_type_tag=ARRAY TAG
.It http_content_type_boundary_tag=ARRAY TAG

.It http_endpoint_tag_force={yes|no}
.It http_method_tag_force={yes|no}
.It http_server_tag_force={yes|no}
.It http_port_tag_force={yes|no}
.It http_body_tag_force={yes|no}
.It http_format_tag_force={yes|no}
.It http_content_type_tag_force={yes|no}
.It http_content_type_boundary_tag_force={yes|no}
These options allow the default endpoint, server and/or port to be overridden by array values in messages from senders of httpclient,
identified by the tag of the value.
If the
.B force
options are set to yes, the specified tags are required to be present in all messages and non-conforming messages will be dropped.

The parameter
.B http_meta_tags_ignore
controls whether or not these parameters are sent as-is along with queries in addition to their usual function.

If
.B http_content_type_boundary_tag_force
is set to yes, the tag is only required to be present if the active content type is
.B multipart/form-data.
Any value from
.B http_content_type_boundary_tag
will only be used if the active content type is multipart/form-data.

Values from the message, although they will be attempted converted, should be of the
.B str
type or binary data. The
.Xt mangler (PA)
module can be used to convery values if needed.
The endpoint, method, server or port must not contain any NULL characters.

If the HTTP server responds with a redirect, the redirection will be followed and values from the messages will not be used except from the HTTP method.
To disallow redirection, use the
.B http_max_redirects
parameter.

Any endpoint from the message may contain a query string, in which any other parameters will be appended to this query string if GET method is used with array values.

If
.B http_body_tag
is used and an HTTP body is found in the message, any array tags specified will be ignored.
If the HTTP method being used does not have a body, like GET, the body data parameter is ignored silently.
The content-type of the resulting request will be 'application/octet-stream' unless overridden using
.B http_content_type_tag .

The parameter
.B http_content_type_tag
affects the Content-Type headers sent for queries with a body specified using
.B http_body_tag
and
.B raw
format.
The excact string specified in the array value with the matching tag will be used as Content-Type.
Other requests are not affected. 

The parameters
.B http_method_tag
and
.B http_format_tag
are used to override the request metod and body format of HTTP requests.
They correspond to the configuration parameters
.B http_method
and
.B http_format
resectively, and the same values may be used in the messages.

Any value specified for HTTP format in a message is ignored if a HTTP body is also present (precence of body implies 'raw' format).

.It http_taint_tag=ARRAY TAG
The specified tag of vain type will be added to generated response messages of array type.
In addition, any received messages from senders in which this tag is present will be ignored.
If left unset, no taint tag will be used.

.It http_report_tag=ARRAY TAG
If set, and the given tag is present in any received messages from senders,
the tag and its value will be added to any messages generated as a result of the query it produces.

The parameter
.B http_meta_tags_ignore
controls whether or not this parameter is sent as-is along with queries in addition its usual function.

The parameter
.B http_receive_ignore_error_part_data
controls whether or messages are generated for error responses.

.It http_meta_tags_ignore={yes|no}
Ignore any meta tags when array values to the HTTP query (controlled by)
.B http_tags.
If set to no, the meta fields may be added to query string or form data body as any other field. Defaults to yes. 

.It http_endpoint_from_topic={yes|no}
.It http_endpoint_from_topic_force={yes|no}
If
.B http_endpoint_from_topic
is set to yes, the MQTT topic of received messaged will be used as the HTTP endpoint. A slash / will be prepended to the topic.
If force is set to yes, messages without a topic will be dropped.
May not be used together with
.B http_endpoint_tag.

.It http_msgdb_socket=PATH
If this parameter is set with a path to the listening socket of the
.B msgdb
module (message DB), filesystem storage of any failed PUT requests will be activated.
The message DB module must also have an instance in the confiuration and listen on the same socket,
but it is not a requirement that it is run by the same instance of RRR.

Any stored messages will not be deleted from the database until a successful request has been performed.

The messages will be indexed by using the mqtt topic of the messages, and messages without topics cannot be stored.
If a message is to be stored in the message DB while a message with the same topic already exists, the old message will be overwritten.

Messages are guaranteed to be sent to the server
.B at least once
, and it is possible under certain server failure conditions and/or high load that some  messages may be sent twice to the server.

Note that if the same msgdb is used for multiple
.B httpclient
instances, an instance will find messages from the others.

Refer to the
.B msgdb
section for more details.

.It http_msgdb_poll_interval_s=SECONDS
Number of seconds between each index request to the message db server, defaults to 30.

.It http_fields=HTTP FIELD NAME[=VALUE][,...]
.It http_tags=ARRAY TAG[->HTTP FIELD NAME][,...]
.B http_tags
is a comma separated list of array tags to find in RRR messages from other modules.
If left unspecified, all array values found will be sent to the HTTP server in default configurations.
If a tag is postfixed with a
.B HTTP FIELD NAME,
this name instead of the array tag name when sending data to the HTTP server.
If tags are specified and an RRR message from a sender is missing one or more of the specified tags, an error is produced.

.B http_fields
is a set of fixed fields to send to the HTTP server, optionally with values. Values from
.B http_fields
are sent regardless of the configuration of
.B http_tags.

If a message is to have it's raw body sent in a PUT, PATCH or POST request, controlled by
.B http_body_tag,
fields from these parameters will not added to the query.

.It http_rrr_msg_to_array={yes|no}
Convert fields in RRR messages from other modules to array values. The fields used are
.B timestamp, topic
and
.B data.
These values may be used in the same way as any other array values from the messages, they may also be matched in the
.B http_tags
parameter. If
.B http_tags
is specified, values from the RRR message will only be sent if they are specified here. Defaults to 'no'.

.It http_no_data={yes|no}
Ignore all data in RRR messages from other modules. Only query values in
.B http_endpoint
and
.B http_fields
, if specified, will be sent to the server. Defaults to 'no'.

.It http_drop_on_error={yes|no}
If there is any error with sending a message while connecting to the server, drop it.
Errors will be logged regardless of this setting.
PUT messages which are stored in the message DB will be retried at the next message DB poll should they be dropped as a result of a connection error (see
.Xr http_msgdb_socket
).
Defaults to 'no' which means that connecting will be retried until a timeout is reached or indefinitely.

.It http_message_timeout_ms=MILLISECONDS
Timeout for deferred messages, defaults to 0 which means no timeout.
Messages being defered to fhe message DB (see
.Xr http_msgdb_socket
) will not get affected by this parameter, as the timer is reset every time they are read back from the DB.
Note that the timeout, if set too low, might cause messages to get dropped before any request has been produced.
If the timeout is set too high or is not set, messages may accumulate in memory.

.It http_low_priority_message_timeout_factor=FACTOR
If
.B http_low_priority_put
is set to "yes", this timeout will apply to low priority messages.
The factor given is multiplied with the value of
.B http_message_timeout_ms
to produce the timeout used.

If not given, a factor of 10 is assumed. The value may be set to 0 to disable timeout for low priority messages.

.It http_ttl_seconds=SECONDS
When the time timestamp of a message in the send queue becomes older than the specified amount of seconds, it is dropped.
The message will also get deleted from the message DB if used (see
.Xr http_msgdb_socket
).
Defaults to 0 which means that TTL check is not performed.

.It http_max_redirects=UNSIGNED INTEGER
The maximum number of redirects to allow from the server for a single message. May be set to 0 to disallow redirects. Defaults to 5, maximum is 500.

.It http_accept=STRING
If specified, an Accept: header field will be sent with all requests containing the given value. If
.B http_accept=application/json
is specified,
.B Accept: application/json
will be sent to the server. Note that it is not possible to specifiy a value with newlines.

.It http_receive_part_data={yes|no}
.It http_receive_json_data={yes|no}
Any combination of yes and no is allowed for the receive options. By default, no messages are generated by
.B httpclient

When receiving part data, HTTP response data is put into messages for other modules to read from httpclient.

When receiving JSON data, multiple RRR array messages may be generated for every response.
Every JSON object containing bare associative values will result in a separate RRR message, regardless of of it's position in the object tree.
A good solution might be to have the server send one or more JSON objects representing data records, all contained in a JSON array.
A maximum of four object tree levels are parsed.

Httpclient will attempt to parse any received data as JSON, regardless of what content type has been set.
Should the parsing fail, no error messages are printed unless debuglevel 2 is set.  

If the original message which caused the query had a topic set, this topic will be present in generated messages. 

.It http_receive_structured={yes|no}
If set to yes, generated messages will be RRR array messages. The following fields will be available in the messages:

.Bl -tag -width -indent
.It http_response_code
The HTTP response code.
.sp
.It http_content_type
The content type from the HTTP header, or empty string if not present.
.sp
.It http_body
The raw response body, or empty string if not present.
.El

The
.B http_body
tag will not be present for JSON messages.
Also, if the JSON data in the response contains any of the above fields, both will be present in the message
with the HTTP-response fields being placed first.

.It http_receive_ignore_error_part_data={yes|no}
If set to no, attempts will be made to create messages from the part data of any responses from the server, even
if they are error responses (HTTP response code is less than 200 or more than 299).
If set to yes or left unset, no messages will be generated from error responses.

.It http_receive_404_as_empty_part={yes|no}
If set to yes and a 404 NOT FOUND response is received, an empty RRR data message will be created.

If set to no or left unset, no such messages are created upon 404 responses.

This parameter is not affected by
.B http_receive_ignore_error_part_data
and does not affect any other parameters.

.It http_low_priority_put={yes|no}
If set to yes, messages which are to be sent using the PUT method will be prioritized behind other messages. This
can improve performance in certain applications if stores are slow.
If set to no or left unset, PUT messages will be treated as other messages.
	
.It http_silent_put_error_limit_s=SECONDS
If a PUT query fails due to the server returning an error code, do not print any error message about this before the message which generated the query has reached the specified age in seconds.
This is useful if failed PUT are stored in a message DB and an error messages need not be printed immediately as the store is attempted again later.
Defaults to 0 which means that all errors are printed regardless of the age of the messages.

.It http_plain_http2={yes|no}
In non-TLS mode, send requests using HTTP2 without upgrading through HTTP/1.1. Note that some servers may get confused by this (but the RRR httpserver module supports it). Defaults to no.
This parameter is ignored if
.B http_version_10
is set to yes.

.It http_no_http2_upgrade={yes|no}
If set to yes or left unset, An 'Upgrade: h2c' header, along with associated headers, will be sent with all HTTP/1.1 queries.
The server will usually either respond by confirming upgrade to HTTP/2 or simply continuing using HTTP/1.1.
If set to no, no such upgrade header will be sent.

.It http_concurrent_connections=UNSIGNED INTEGER
Maximum number of concurrent connections to open for each host/port combination. Defaults to 10, minimum value is 1 and maximum value is 65535.

.It http_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional.
.El
.SS msgdb (N)
The message DB saves messages on the file system for persistence across program restarts.
Clients may connect to the message DB using a UNIX socket and perform REST-like (REpresentional State Transfer) queries to save and retrieve messages.

Messages are stored with their filename being the SHA-256 hash of their topic. Messages with empty topics cannot be stored.

Using the socket is the only way to communicate with the message DB, it cannot read from other modules nor can it be read from.

Currently only internal modules may use the message DB, and the methods GET, PUT, DEL and IDX are available to them. 

Messages are stored with all fields in network byte order. The may be deleted and moved in and out of the storage directory at any time, but any modifications
may render message checksums invalid. The utility
.Xr rrr_msg(1)
can be used to check and read messages which are stored on disk.

.B ANY FILES in the specified directory which cannot be read, will be interpreted as corrupt RRR-messages and WILL BE DELETED.

The following configuraton parameters are available in the
.B msgdb
module:

.Bl -tag -width -indent
.It msgdb_directory=DIRECTORY
The directroy to store files in. Defaults to '/var/lib/rrr/msgdb'.
Multiple instances of the Message DB should not use the same directory and the directory must not be used to store anything else.

.It msgdb_socket=FILENAME
The path to the socket to which clients connects.
Defaults to 'msgdb.sock' in the currrent run directory from the environment (typically /run/rrr).

.It msgdb_directory_levels=LEVELS
The number of directory levels to use when storing files. Each file will be placed into a directory corresponding to the first letters of its name.
A file beginning with 'af432...' will be placed in the directory 'a/f/' if LEVELS is set to be 2.
Must be in the range 0 to 4 inclusive, defaults to 2.
.El

.SS incrementer (PA)
Incrementer will append unique ID numbers to messages matching a specified topic filter.
If wildcards are present in the filter, an separate ID counter will be used for each unique topic matching the filter.
The ID counters may be initialized by passing in messages with a start ID value in a specific tag, or they may begin at
the lowest allowed value.
Any initialization messages are ignored if an ID is already initialized.
If a message DB socket is specified, the latest used ID's will be stored on disk for persistence across restarts.

When messages are allocated an ID, a number following a slash / is appended to the topic before the messages
are sent to the output buffer for other instances to pick up.

If a message with the topic
.B my/topic-a
is given to incrementer and matches the active configuration, the topic will be changed to
.B my/topic-a/UUU
where UUU is the allocated numberic ID. The allocated IDs are 32-bit unsigned integers which gives a maximum value of 4.294.967.295
which when reached wraps back to the minimum value.

If unique IDs need to be generated across different hosts, there are two methods of ensuring that unique IDs are generated.
Both methods may be used simultaneously.

.B Modulus and position

IDs will be generated by adding a modulus to the last used ID, and then using the position within the modulus to
determine which ID to use.
The modulus represent at least the number of ID generators, and the position represent one specific generator.

.B Prefix

A prefix may be given which is ORed with generated IDs.
The prefix may either be specified in the configuration, or in case
.B incrementer_id_tag
is used, the ID being supplied must contain the prefix.

The following configuration parameters are available in the incrementer module:

.Bl -tag -width -indent
.It incrementer_subject_topic_filter=MQTT TOPIC FILTER
The topic filter for messages to process, required parameters. Wildcards # and + are allowed per MQTT standards.
Messages received which do not match will be passed through to the output buffer unmodified.
To prevent other messages from being received to incrementer all together, set the same filter in the general
.B topic_filter
parameter or use routing.

.It incrementer_msgdb_socket=PATH
If specified, used IDs will be stored on disk using Message DB. An instance of
.B msgdb (N)
must be running and listening on the socket.

.It incrementer_id_tag=TAG
If specified, all topics for which to allocate IDs must be pre-initialized. This is done
by passing a message to
.B incrementer
containing a start ID number in a value with the given tag.

Initialization does not persist across restarts, and to retain an initialized ID, a generation must be triggered.
Once an ID has been generated, the initializion value will no longer be used.
If multiple initializations are sent, the last one takes precedence.

If a fixed prefix is used through the parameter
.B incrementer_id_prefix
being non-zero, the ID given must contain this prefix.
Otherwise, if the ID given contains a prefix, this will continue to be used for successive ID generations.

.It incrementer_id_min=UNSIGNED INTEGER
The lowest ID to allocate, defaults to 1.

.It incrementer_id_max=UNSIGNED INTEGER
The maximum ID to allocate, default to 4.294.967.295.

.It incrementer_id_prefix=UNSIGNED INTEGER
The prefix to use for generated IDs.
Defaults to 0 which means that no prefix is used unless IDs with prefixes are supplied through initialization using the
.B incrementer_id_tag
parameter.

Generated IDs will be prefixed with the given value so that the bits required
to represent the maximum ID set in
.B incrementer_id_max
occupies the least significant bits of the ID and the prefix occupies the remaining
bits.
The total number of bits may not exceed 64.

.It incrementer_id_modulus=UNSIGNED INTEGER
The modulus (increment step) to use, defaults to 1 which is also the minimum value. Maximum value is 255.

.It incrementer_id_position=UNSIGNED INTEGER
The position within the modulus to use for IDs. Defaults to 0, maximum value is 254 and must be less than modulus.
.El

The max and min values must otherwise be set so that the modulus fits between them.
The consistency of the configuration parameters will be checked during startup.
Any ID which after incrementation gets a value less than min or more than max will
be reset to a low value matching the modulus and position parameters.

The algorithm used for calculating ID numbers:

\(bu IDo  = Old ID (last allocated)
.br
\(bu IDn  = New ID
.br
\(bu IDl  = Lowest ID
.br
\(bu IDh  = Highest ID
.br
\(bu m    = Modulus
.br
\(bu p    = Position

.EX
IDn1 = IDo - (IDo mod m) + m + p

If IDn1 < IDl or IDn1 > IDh, then IDn2 = IDl - (IDl mod m) + p
                             else IDn2 = IDn1

If IDn2 < IDl, then IDn = IDn2 + m
               else IDn = IDn2
.EE

\(bu If the modulus is set to 2 and position set to 0, only even IDs will be allocated.
.br
\(bu If the modulus is set to 2 and position set to 1, only odd IDs will be allocated.

After a new ID has been generated, it will be ORed with any configured prefix.
When prefixes are in use, the algorithm expects any old stored ID, or ID used for initialization,
to be prefixed with the same value.

TODO Explain negotiation

.SS cacher (PA)
The
.B cacher
uses a message database to store messages on disk.
Messages received are stored into the database, and it is possible to have messages read back
by passing in request messages.

.Bl -tag -width -indent
.It cacher_msgdb_socket=PATH
An instance of
.B msgdb (N)
must be running and listening on this socket.
All messages received will be sent to the specified message database for storage, unless the messages
are request messages. Only one message per unique topic will be stored. Mandatory parameter.

.It cacher_request_tag=TAG
If the specified tag exists in a message, the message will be treated as a request message.
The topic of the message is used to search in the message database, and if a message exists with the same topic, this
message is passed to the output buffer.
Optional parameter.

.It cacher_forward_requests={yes|no}
If set to yes, messages which are treated as requests are passed to the output buffer.
Defaults to no.
See also
.B cacher_memory_consume_requests.

.It cacher_forward_data={yes|no}
If set to yes, messages which are not treated as requests (thus are to be stored) are passed to the output buffer.
Defaults to no.

.It cacher_forward_other={yes|no}
If set to yes, messages without topic are forwarded.
If set to no or left unset, messages without a topic are dropped and an error message is produced.

.It cacher_request_receivers=INSTANCE NAME,...
.It cacher_data_receivers=INSTANCE NAME,...
.It cacher_other_receivers=INSTANCE NAME,..
.It cacher_revive_receivers=INSTANCE NAME,...
Define a list of readers of this cacher instance to receive request, data, other or revived messages.
The instances defined must have this cacher instance defined as a sender.
Note that
.B
duplicate=yes
should be set when there are multiple readers of the cacher module.
If left undefined for one or more of the message types, all readers will receive this type.

These parameters may not be used if the
.B route
parameter is set for the cacher instance.

.It cacher_memory_consume_requests={yes|no}
If set to yes and a request matches a message in the memory cache, the request will not be forwarded regardless of the
.B cacher_forward_requests
parameter.
If set to no or left unset, the parameter
.B cacher_forward_requests
will control whether the request is forwarded or not.

.It cacher_empty_is_delete={yes|no}
If set to yes, an empty message which otherwise would be stored will instead cause deletion of any previously stored message with mathcing topic.
If set to no, empty messages will be stored.

.It cacher_no_update={yes|no}
If set to yes, no writes will be performed and all messages which are not requests will be treated as 'other'.
Defaults to no.

.It cacher_ttl_seconds=SECONDS
Any messages received from other modules with an age older than the set value is silently dropped.
In addition, the age of messages in the message database is checked whenever tidy is performed.
Defaults to 0 which means that TTL check is not performed.

.It cacher_memory_ttl_seconds=SECONDS
Messages which are to be stored in the message database will also be stored in the memory cache and deleted after this specified TTL expires.
When a request message is received and a matching message is found in the memory cache, the cached message will be passed to the output buffer and the message database will not be consulted.
The memory cache is checked for TTL when potential matches are found or every 5 minutes.
If set to 0 or left unset, memory cache is not used.

.It cacher_revive_age_seconds=SECONDS
Messages in the cache older than the specified age in seconds will be read out and put into the output buffer.
If set to 0 or left unset, message revive will be deactivated.

.It cacher_revive_interval_seconds=SECONDS
Specify how often cacher will check for messages to revive.
The interval is calculated from the last time the revive process completed.
Defaults to 60 seconds (1 minute), the minimum value is 1 second.

.It cacher_tidy_interval_seconds=SECONDS
Specify how often cacher will iterate through the cache for simple integrity checks and to look for expired messages.
The interval is calculated from the last time the tidy process completed.
Defaults to 300 seconds (5 minutes), the minimum value is 1 second.

.El

.SS mqttbroker (N)
An MQTT broker supporting V3.1(.1) and V5.
.PP
The following configuration parameters are available in the
.B mqttbroker
module:
.PP
.Bl -tag -width -indent
.It mqtt_broker_port=PORT
TCP port to listen on (listens on all interfaces). Defaults to 1883.

.It mqtt_broker_port_tls=PORT
TCP port to listen on for TLS connections (listens on all interfaces). Defaults to 8883.

.It mqtt_broker_transport_type={plain|tls|both}
The transport type to use when listening. Defaults to 'plain'.

.It mqtt_broker_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional except from certificate file and private key.
.It mqtt_broker_max_keep_alive=SECONDS
Maximum keep-alive value for clients, defaults to 30.

.It mqtt_broker_retry_interval=SECONDS
Retry interval for QoS1 and QoS2 messages.

.It mqtt_broker_close_wait_time=SECONDS
After disconnect, wait this many seconds before closing the socket (make client close first to avoid TIME_WAIT). Defaults to 1 second.

.It mqtt_broker_v31_disconnect_on_publish_deny={yes|no}
If a V3.1 or V3.1.1 client sends a PUBLISH which is rejected by ACL rules, the client will be disconnected
if this option is set to yes. The default value is no, which means that the broker sends an acknowledgement packet
regardless of whether the PUBLISH was rejected or not. For V5, an acknowledgement with an error code is always sent,
disregarding this option.

.It mqtt_broker_password_file=FILENAME
Filename of an RRR password file created by
.Xr rrr_passwd(1)
with which users are authenticated. If left unspecified, all CONNECT packets containing a username will be rejected.
RRR does not allow CONNECT packets only containing usernames, a password must always be set.

.It mqtt_broker_permission_name=PERMISSION
The permission name to which a user must have been registered with by using
.Xr rrr_passwd(1)
to become authenticated with this broker. Defaults to
.B mqtt. 

.It mqtt_broker_require_authentication={yes|no}
Disallow anonymous logins. This defaults to 'yes' if a password file is set, otherwise it defaults to 'no'.

.It mqtt_broker_acl_file=FILENAME
ACL file to allow different users access to topics. If left unspecified, all access is granted. If a file is specified and a rule
is not found upon a PUBLISH or SUBSCRIBE from a client, access will be denied.
.PP
The ACL file consists of one or more
.B TOPIC {TOPIC STRING}
blocks. The
.B TOPIC STRING
value is an MQTT filter in which # and + are allowed according to the MQTT specifications. Curly brackets are not to be included.
.PP
A topic block may contain one or more lines beginning with one of the keywords
.B USER
or
.B DEFAULT
followed by one or more spaces or tabs. Keywords are case-insensitive.
.PP
The
.B DEFAULT
keyword takes one argument, an ACL action (DENY, READ or WRITE). If left unspecified, the default action is DENY.
.PP
The
.B USER
keyword takes two arguments, a username followed by one or more spaces or tabs and an ACL action (DENY, READ or WRITE).
.El
.PP
If
.B READ
access is granted, a user may SUBSCRIBE to the matching topics. If
.B WRITE
access is granted, a user may SUBSCRIBE and PUBLISH to the matching topics.
.B DENY
will block all access to the matching topics. 
.PP
The ACL file is parsed from top to bottom, and the bottom most matching rule will take precedence.
.PP
Comments may be placed on separate lines and begins with '#'. Spaces and tabs are allowed on the beginning of a line before keywords.
.PP
Below follows some example rules:
.PP
.EX
# BEGIN ACL FILE
# Allow access to everything from everyone
TOPIC #
	DEFAULT WRITE

# Allow only READ access on $SYS topics, but allow system_user to WRITE
TOPIC $SYS/#
	DEFAULT READ
	USER system_user WRITE
# END ACL FILE
.EE
.PP
The MQTT server follows the specifications from Oasis, but lacks support for the following (will be implemented shortly):
.PP
\(bu AUTH packet (simple username/password implemented)
.PP
.SS mqttclient (PA)
An MQTT client supporting V3.1.1 and V5. The client will publish RRR messages it receives from other modules, and
other modules can read messages the client receives on subscribed topics.
.PP
The following configuration parameters are available in the
.B mqttclient
module:
.PP
.Bl -tag -width -indent
.It mqtt_server=HOST
Host name or IP of the broker to connect to. Defaults to localhost.

.It mqtt_server_port=PORT
TCP port on the server for TLS connections, defaults to 1883 for plain transport and 8883 for TLS connection.

.It mqtt_transport_type={plain|tls}
The transport type to use when connecting to the server. Defaults to 'plain'.

.It mqtt_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional.

.It mqtt_client_identifier=IDENTIFIER
Client identifier to use. If left unspecified, the broker picks one.

.It mqtt_v5_recycle_assigned_client_identifier={yes|no}
If we let the broker pick a client identifier and we are using protocol version 5, the broker will inform the client
about which client identifier it assigned. If this option is set to yes and the client needs to re-connect for some reason,
it will attempt to use this assigned client identifier. In version 3, the broker does not inform the client about the
picked client identifier and this option is then ignored. Defaults to 'yes'.

.It mqtt_connect_error_action={restart|retry}
Default action if connecting to the server failed. If set to
.B restart,
all RRR modules will be restarted after a few connection attempts (might cause messages to be lost). If set to
.B retry,
the client will keep trying to connect without any restart (messages will not be lost). Default action is to restart.

.It mqtt_connect_attempts=NUMBER OF ATTEMPTS
How many times we attempt connecting to the broker before giving up.
What we do when this number is reached depends on the setting
.B mqtt_connect_error_action.
One connection attempt lasts approximately 100ms. Must be 1 or more, defaults to 20.

.It mqtt_discard_on_connect_retry={yes|no}
With this option set to 'yes' while
.B mqtt_connect_error_action
is 'retry' and a connect retry is performed, queued messages will be read from all senders and discarded. This might be needed
to avoid non-processed messages filling up memory in situations where the broker is not available for a longer period. If however
.B  mqtt_connect_error_action
is 'restart', all messages will be cleared anyway when all instances restart after mqttclient fails to connect.
.B mqtt_discard_on_connect_retry
may not be set to 'yes' in this situation. Defaults to 'no'.
  
.It mqtt_username=USERNAME
.It mqtt_password=PASSWORD
Optional username and password to send in CONNECT packets. If a password is set, a username
.B must
also be set. Note that the RRR MQTT broker disallows connects with username only, other brokers might handle this differently.

.It mqtt_qos={0|1|2}
Default Quality of Service to use, defaults to 1.

.It mqtt_version={3.1.1|5}
Default MQTT protocol version to use, defaults to 3.1.1.

.It mqtt_publish_topic=TOPIC
Topic to use when publishing RRR messages without topic set in them.
If left unspecified, RRR messages without a topic will be dropped.

.It mqtt_will_topic=TOPIC
If set, a will topic will be set as MQTT client connects to the broker.
A PUBLISH message will be generated by the broker if the client unexpectedly disconnects.
Other will-related parameters require this parameter to be set.

.It mqtt_will_message=STRING
If set, any generated will message will have the given string as message body.

.It mqtt_will_qos={0|1|2}
Default Quality of Service to use for will message, defaults to 1.

.It mqtt_will_retain={yes|no}
If given and set to yes, the retain flag will be set for will messages.

.It mqtt_publish_topic_force={yes|no}
Force use of the topic specified in
.B mqtt_publish_topic
and disregard any topic in RRR messages. Cannot be used with
.B mqtt_publish_topic_prepend.
Defaults to no.

.It mqtt_publish_topic_prepend={yes|no}
The topic specified in
.B mqtt_publish_topic
is prepended to the topic RRR messages. No trailing or leading slashes are added. Cannot be used with
.B mqtt_publish_topic_force.
Messages without a topic are dropped if set to yes. Defaults to no.

.It mqtt_publish_rrr_message={yes|no}
If set to 'yes', the client will send full RRR messages. This may be used with
.B mqtt_receive_rrr_message
being set to 'yes' in the configuration of the client which subscribes to the messages.
If set to 'no' or left unset, one of the following data compositions are used given in order of precedence:

.Bl -tag -width -indent
.It Array data
If
.B mqtt_publish_array_values
is set, data formatted according to this parameter is published.

.It Raw data
If the data field of the RRR-message has a size greater than one, and it is not an array message, this raw data
is sent. This method should be used for passing simple text messages or other data.

.It Descriptive string
A string showing the type, class and timestamp of the RRR-message is put into the resulting PUBLISH message.

.El

.It mqtt_retain_tag={tag}
If set and an incoming array message has the tag present, the resulting PUBLISH message will have the retain flag set.

If the contents of the array value is the word "clear" without the quotes, an empty PUBLISH message will be sent to the broker instructing it to delete any pending retained message.
Any data will not be processed for this message.

If the contents of the array value is an unsigned number, this is used to set the expiry interval in seconds of the message.
The broker will delete the retained message after the specified amount of seconds has passed.
If the number is set to 0 or if the active protocol version is not 5, the retain message will never expire.

If the contents of the array value is anything else or not present, the contents is ignored. 

.It mqtt_publish_array_values={*|tag1[,tag2[,...]]}
Put all values from an array (*) or selected values (by tag) into the payload of PUBLISH messages. RRR
messages which do not contain an array are dropped. Any integer types will have big endianess in the resulting publish message.
Cannot be used with
.B mqtt_publish_rrr_message=yes.

.It mqtt_subscribe_topics=TOPIC1[,TOPIC2[,...]]
MQTT topic patterns to subscribe to (if any)

.It mqtt_receive_rrr_message={yes|no}
Expect to receive RRR messages from the broker.
If set to yes, any messages received which are not RRR messages are dropped.
If set to no and protocol version is V3.1.1, any data in messages received are put into a new RRR message.
If set to no and protocol version is V5, type of the received message is auto-detected.
Defaults to no.

.It mqtt_receive_publish_topic={yes|no}
When an RRR message is found inside a received PUBLISH and this parameter is set to 'yes',
modify the RRR message and replace its topic with the topic from the PUBLISH message.
If set to 'no' or left unset, the RRR message will retain is original topic, if any.

.It mqtt_receive_array=ARRAY DEFINITION
If set, expect to receive data arrays of specific formats in publish messages.
This option cannot be used with mqtt_receive_rrr_message=yes, however if protocol version is V5,
received RRR messages will still be auto-detected, and array parsing will not occur for these.
Multiple data array records may reside in a single PUBLISH message, one RRR message will be generated for each record. 
Refer to
.Xr rrr_post(1)
for syntax of array definitions.
.sp
.It mqtt_command_topic_filter=TOPIC FILTER
If set, messages in which the given topic filter match will be treated as command messages.
Command messages contains commands to the MQTT client itself which change its behaviour and do not result in any messages being published.

Any commands sent will override corresponding configuration parameters, but if RRR due to some error condition restarts, any parameters set using commands will be lost.

String-compatible values with special tag names are set in the array message.
The command to perform is set in the value
.B mqtt_command.
Other values to set is different depending on the command.
Debuglevel 1 may be activated to print information about command processing.

Possible commands are:
.sp
.Bl -tag -width -indent
.It subscribe
Topics to subscribe to are set in the field
.B mqtt_topic_filter.
The field may be set multiple times, do not separate topics with comma. The given topics are added to any existing topics currently subscribed to and a SUBSCRIBE packet is sent to the broker for all current subscriptions.
.It unsubscribe
Topic filters are set as with the
.B subscribe
command. The client will unsubscribe from the given topics. Error messages may be printed if subscriptions do not already exist.
.It disconnect
The client will disconnect from the broker after which an automatic reconnect occurs.
If the field
.B mqtt_disconnect_with_will
is present, any will message is activated (an abrubt disconnect is done for version 3.1.1 and disconnect with will is sent for version 5).
.El
.El

.SS journal (SA)
Picks up RRR journal log messages and places them into arrays for other modules to read. Please note that this is not possible
to do with certain debuglevels active as passing messages generated by
.B journal
would cause generation of even more messages at an exponential growth rate.
.PP
RRR log messages from
.B journal
will have their MQTT topic set to
.B rrr/journal/{log_prefix}
where {log_prefix} (without curly brackets) is set by the originating module. It is not possible to change this topic,
but it may be changed in other modules which use these messages if required. See more details further down.
.PP
If a global debuglevel other than 1 is active, ...
.PP
\(bu all messages with a loglevel other 1 will be suppressed.
.br
\(bu messages from custom scripts which generate log messages (regardless of debuglevel) on other loglevels than 1 will be suppressed.
.br  
\(bu all log messages are still delivered to
.Xr rrr_stats(1)
and printed out (and delivered to syslog if RRR is an systemd daemon).
.PP
The following array tags can be retrieved from messages generated by
.B journal:
.PP
.Bl -tag -width -indent
.It log_level_translated
RFC 5424 loglevel, small integer.
.It log_prefix
The log prefix, usually path to the current RRR configuration file.
.It log_message
The actual log message (including syslog-syntax for loglevel and prefix)
.It log_hostname
The hostname of the current host or overridden hostname from configuration file.
.El
.PP
Messages generated while RRR is processing a signal are not delivered to
.B journal.
.PP
The following configuration parameters are available:
.PP
.Bl -tag -width -indent
.It journal_generate_test_messages={yes|no}
Generate dummy messages for testing purposes. Defaults to no.

.It journal_hostname=HOSTNAME
Hostname to send along with log messages. Defaults to system hostname.
.El

.SS file (PA)
Reading and writing to or from files, character devices, block devices, sockets and FIFO pipes.
Full file contents may be read into RRR messages, or and array definition may be used to create RRR array messages from the data.
The
.B file
module periodically checks for new entries in the specified directory and tries to read from them.
.PP
.B THIS MODULE MAY READ AND WRITE ANYWHERE ON THE FILESYSTEM IN CERTAIN CONFIGRATIONS

When instructing the file module to write to a specific file path using a paths from array messages, ensure
that the paths used does not come directly from outside.
Note that when writing to a file, the file module may also start reading from the same file if configured to do so.
Make messages with paths within RRR only (in a script module).
.PP
Sockets, character devices and FIFO pipes are kept open until the other end closes them or EOF is encountered.
If disconnected,
.B
file
with attempt to reconnect with them in the next probe round unless they are deleted in the meantime.
FIFO pipes can be created with the
.Xr mkfifo(1)
command, and they can be written to easily with commands like
.B echo "blabla" > /tmp/rrr/my_rrr_fifo .
.PP
The
.B file
module can be used to manage a "drop" directory where other programs put files which are to be read into RRR.
When doing this, one must avoid that
.B file
tries to read files before they are completely written out.
This can be achieved by specifying a file prefix in the configuration and writing the files first with some temporary name
before finally, when writing is complete, renaming them to something matching the prefix.
.B file
may be configured to delete files after they are read.
.PP
There is no limit on how many files, sockets etc. which can be simultaneously open.
.PP
Messages read from sender instances contain data and information on where to store it.
Note that if files are written, these files may also be read back if their name matches the prefix.
Use different prefixes for written files to avoid this or disable probing using
.B file_no_probing
if reading need not be performed.

If any senders are specified for a file instance, making writing possible,
write access is required for all files to be opened regardless of whether writing is actually performed or not.
If no writing is possible, files will be opened read-only.

If a normal file is already open for reading when writing starts, seek will be performed to either the beginning or end of the file depending on the
.B file_write_append
parameter.
Any ongoing reading operation will stop, but the file may be read from at a later time depending on the configuration.

If writing is performed to a stream device, these will also be read from.

Failure to open files are typically ignored silently.
Use debuglevel 3 to print more information about failures.

If the type of
.B file_data
is
.B str,
a quoted string will be output in the file.
If this is not wanted, use the
.B blob
type instead, possibly by converting the value using the
.B mangler
module.

The following array fields are used in write messages to the file module:
.PP
.Bl -tag -width -indent
.It file_directory
If the configuration
.B file_write_allow_directory_override
is set to yes, this value may be present in the message to override the directory of where the file is located.
.It file_name
The name of the file to open to save the data.
The file must be located inside the directory being used and the name may not contain directories (e.g. slashes).
.It file_data
The data to write to the file.
If the configuration parameter
.B file_write_array_values
is used, the given array values are used instead.
.El

.PP
The following configuration parameters are available in the
.B file
module:
.PP
.Bl -tag -width -indent
.It file_directory=DIRECTORY
Directory in which to probe for files to read from, must be set.
If the directory does not exist or cannot be opened, the file module will not start.

.It file_prefix=FILE PREFIX
Optional prefix for files to read from in the chosen directory. Non-matching files are ignored.

.It file_probe_interval_ms=MILLISECONDS
Probing for new files is done immediately after startup and then periodically every time the probe interval has passed.
A value of zero is allowed, this might be CPU intensive. Defaults to 5000 ms.

.It file_no_probing={yes|no}
If set to 'yes', no probing for files in the specified directory will be performed.
If set no 'no' or left unset, files will be read.

.It file_topic=MQTT TOPIC
Set an MQTT topic on generated messages. Optional parameter.

.It file_input_types=ARRAY DEFINITION
Parse array data from the entries found.
Reading will stop when there is an error or when EOF is encountered.
Cannot be used with
.B file_read_all_to_message=yes,
but one of them must be specified. No default value.

.It file_add_metadata={yes|no}
If
.B file_input_types
is set, this parameter may be set to 'yes' to add file metadata to messages produced.
The fields added will be the same as for the read all method 'structured' below except from the
.B data
and
.B size
values.
The fields will be added to the end of the array, after the parsed data values.
There is no checks for wether or not tags in the array definition are the same as any of the metadata tags, duplicate tags may exist in the array in such a situation.
Defaults to 'no' which means that metadata will not be added.

.It file_strip_array_separators={yes|no}
Disregard any separator items when creating RRR array messages. Defaults to no.

.It file_sync_byte_by_byte={yes|no}
If array parsing fails according to definition, keep skipping one byte forward in the stream until a match is found.
Defaults to no, which means to only sync on boundaries of incoming messages.

.It file_read_all_to_message={yes|no}
Read all data from the entries and put it into an RRR message.
Note that with this parameter active, reading is not performed for non-regular files with finite size. Cannot be used with
.B file_input_types,
but one of them must be specified. At most 32 MiB may be read per file. Defaults to 'no'.

.It file_read_all_method={simple|structured|file}
May be set if
.B file_read_all_to_message
is 'yes'.
If set to 'simple', the contents of the file is put into a plain message.

If set to 'structured', the contents of the file along with metadata is put into an array with the following fields:

.Bl -tag -width "aa" -indent
.It data
.It size
The raw data of the file and it's size.
.Pp
.It path_original
.It path_resolved
The original and resolved path (in case original is a symbolic link) of the file respectively.
.Pp
.It atime
.It mtime
.It ctime
Timestamps in epoch format with second resolution. Describe file access time, modification time and creation time. 
.El

If set to 'file', the contents of the file along with metadata is put into an array with the following fields:

.Bl -tag -width "aa" -indent
.It file_data
.It file_size
The raw data of the file and it's size.
.Pp
.It file_directory
.It file_name
The original path of the file before any symbolic link resolving.
.Pp
.It file_path_resolved
The resolved path (in case original is a symbolic link) of the file respectively.
.El

Messages produced using the 'file' method are appropriate for passing into another file module for writing.

.It file_unlink_on_close={yes|no}
After an open entry for any reason closes, attempt to unlink it. Note that
.B any type of file or socket will be deleted
as long as the user running RRR has permission to do that.
Files which were opened as a result of a write operation are not unlinked when closed regardless.
Defaults to 'no' which means that unlinking is never performed.

.It file_max_open=UNSIGNED INTEGER
Maximum number of simultaneously open files. If multiple files are open at the same time,
.B file
will iterate all the files and read read only one message from each of the files at a time.
If there is only one open file, all messages in this file will be processed in order before
a new one is opened.
Defaults to and has a maximum value (if set) of 65536.
May be set to 0 which means that there is no maximum number of open files.

.It file_try_serial_input={yes|no}
If set to yes, an attempt will be made to set serial port parameters on opened files. If left unset or set to no, any serial configuration parameters will be ignored.

.It file_serial_no_raw={yes|no}
If set to yes, do not disable any features on serial ports. If set to no or left unset, XON/XOFF, parity, canonical reading etc. will be disabled.
Note that other configuration options for the serial ports will override this option (features may be re-enabled).

.It file_serial_bps=UNSIGNED INTEGER
If set, set a speed int bits per second like 19200, 38400 etc. on serial serial ports. If left unset, speed settings will be left untoched.

.It file_serial_parity={even|odd|none}
If set and set to 'even' or 'odd', parity will be set accordingly on serial ports. If set to 'none', parity will be forced off. If left unset, parity settings will be left untouched.

.It file_serial_two_stop_bits={yes|no}
If set to yes, use two stop bits on serial ports. If set to no, force one stop bit to be used. If left unset, stop bit configuration is left untouched. 

.It file_try_keyboard_input={yes|no} (LINUX/FREEBSD ONLY)
If set to yes, and character devices are found in the directory,
.B file
will try to read from them as if they were keyboards.
This works with many barcode scanners and other devices which produce keyboard-like event data.
Any device which accept the
.Xr ioctl(3P)
EVIOCGRAB command will be used as a keyboard, and data will be run through a key to character map.
The EVIOCGRAB command, if it succeeds, will make
.B file
the only receiver of data from the opened devices, and due to this, keyboards which are opened will
become unusable.
Care should be taken to ensure that devices are not unintentionally opened by
.B file.
Only US keyboard layout is supported.
Defaults to no.

.It file_no_keyboard_hijack={yes|no}
After a keyboard device has been successfully hijacked thus identified as a keyboard, immediately
ungrab the device so that other applications also may receive events from it. 

.It file_max_messages_per_file=COUNT
After the specified amount of messages has been read rom a file, close it.
Cannot be used with file_read_all_to_message=yes.
Defaults to 0 which means that that any number of messages will be read and the file is only closed on EOF or error conditions.

.It file_max_read_step_size=BYTES
Read as most the specified number of bytes each round.
This parameter is not respected when file_read_all_to_message is 'yes', and having both these parameter specified is an error.
Must be greater than zero, defaults to 4096.

.It file_timeout_s=SECONDS
If no message is read or written in the specified amount of seconds, close the file.
Any messages not yet written are dropped.
Defaults to 0 which means no timeout. 

.It file_write_timeout_ms=MILLISECONDS
If a particular message to write is not written within this time, it is dropped.
Must be set to an interval shorter than
.B file_timeout_s.
Defaults to 0 which means no timeout.

.It file_ttl_seconds=SECONDS
Check the creation timestamp of messages and drop them if they are or become older than the specified amount of seconds.
Defaults to 0 which means that TTL check is disabled.   

.It file_write_array_values={*|tag1[,tag2[,...]]}
Put all values from an array (*) or selected values (by tag) into the file.
RRR messages which do not contain an array are dropped.
Any integer types will have big endianess in the written files.
If left unset, the field
.B file_data
will be used.

.It file_write_append={yes|no}
If set to 'yes', data will be appended to the given file if it already exists.
If set to 'no' or left unset, existing files will be truncated.
This parameter has no effect if the output file is a stream.

.It file_write_allow_directory_override={yes|no}
Allow usage of the array field
.B file_directory
in messages from sender instances, overriding the directory specified in the configuration.
If not given or set to no, any directory set in messages will be ignored.
Read about security considerations above before enabling this parameter.

.It file_write_multicast={yes|no}
If set to yes, any
.B file_name
and
.B file_directory
values in messages are ignored, and the data is written to all files already open.
If no files are open, the message is dropped.
If write error occurs during multicast, the file in question will be closed.
No attempt will be made to write the data again.
Defaults to 'no' which disables write multicast.

.It file_write_mode={MODE}[,MODE]...
If specified, and a newly created or existing file is opened for writing, the given mode will be set on the file.
Refer to
.Xr chmod(2)
for a list of valid modes.
For write to be possible, proper permissions must be given (read + write permissions for the user should always be set).

.El
.SS mysql (DAI)
This module will read in messages from other modules, possibly IP-capable, and save them to a myqsl or MariaDB 
database.
.PP
A column plan must be used to describe the table we are saving to. The received data must match this column plan. If
the data saving for any reason fails, like if the database is down or the table is misconfigured, we cache the failed messages
and try again later. It is not possible for the mysql module to know wether it's settings are at fault or if the database
is at fault. Messages which fails can regardless of this be set to be dropped instead upon errors.
.PP
The following configuration parameters are available in the
.B mysql
module:
.PP
.Bl -tag -width -indent
.It mysql_server=SERVER NAME
The server name of the MySQL or MariaDB server to use

.It mysql_port=PORT NUMBER
The port number used to connect to the server.

.It mysql_user=USER NAME
The username for logging into the server

.It mysql_password=PASSWORD
The password for logging into the server

.It mysql_db=DATABASE NAME
The name of the database to use

.It mysql_table=TABLE NAME
The table name to use for storing data

.It mysql_drop_unknown_messages={yes|no}
If a message fails to be saved into the specified table for any reason, simply delete it instead of trying again later. Defaults to no.

.It mysql_columns={column name 1,column name 2,...}
Specify the columns in the table to write data to. The column count must match the number of values received in array
messages from other modules. The data types only matters to some extent, the columns should be able to hold the data
types received. Integers are sent to the database as integers and blobs are sent as blobs.
If an array contains items with more than one value, one column should be specified for the whole item. These items are always sent
to mysql as blobs.
This option cannot be used with
.B mysql_column_tags.

.It mysql_column_tags=ARRAY TAG[->MYSQL COLUMN][,...]
A comma separated list of items to retrieve from the received array messages and to use as
columns in MySQL. If a tag name is specified on is own, the tag and the corresponding column in MySQL has the same name.
If the MySQL column name is different from the tag, an arrow followed by the MySQL column name is put after the tag name.
This option cannot be used with
.B mysql_colums.

.It mysql_blob_write_columns={column name 1,column name 2,...}
Used to force to send data as blob (raw data) to the database for the specified columns regardless of their type.

.It mysql_special_columns={column1=value1,column2=value2,...}
Used to write fixed values to the database.

.It mysql_add_timestamp_col={yes|no}
In addition to the other columns, write to a column named `timestamp` and save the timestamp from the message here.

.It mysql_strip_array_separators={yes|no}
Disregard any separator items in received array messages. Defaults to yes.
.El
.SS influxdb (DA)
This module receives array messages from other modules and sends their data to an Influx database using HTTP.
.PP
The following configuration parameters are available in the
.B influxdb
module:
.PP
.Bl -tag -width -indent
.It influxdb_server=HOSTNAME
The IP address or hostname of the host running an Influxdb database.

.It influxdb_database=DATABASE
The database name to use on the server.

.It influxdb_table=TABLE
The table in the database in which to store the data.

.It influxdb_port=PORT
The port to use when connecting to the server, defaults to 8086.

.It influxdb_transport_type={plain|tls}
The transport type to use when connecting to the server. Defaults to 'plain'.

.It influxdb_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional.

.It influxdb_tags=ARRAY TAG[->INFLUXDB TAG][,...]
A comma separated list of items to retrieve from the received array messages and which should be used as
.B tags
in InfluxDB. If the tag of an
item in an array is not equal to the tag in InfluxDB, the tag may be followed by
.B ->INFLUXDB TAG
to translate the tag name. 
Items in an array message which are not tagged cannot be used.

.It influxdb_fields=ARRAY TAG[->INFLUXDB FIELD][,...]
A comma separated list of items to retrieve from the array and which are to be used as
.B fields
in InfluxDB. Otherwise same rules as for tags.

.It influxdb_fixed_tags=TAG[=VALUE][,...]
Optional comma separated list of fixed tags (and optionally with values) to save to InfluxDB.

.It influxdb_fixed_fields=FIELD[=VALUE][,...]
Optional comma separated list of fixed fields (and optionally with values) to save to InfluxDB.
.El
It is required to have at least one tag specified in either
.B influxdb_fields
or
.B influxdb_fixed_fields .
.SS voltmonitor (SA)
Read voltage readings from a USB device. For every reading, an array message is generated with the timestamp of the measurement
and the measurement itself.

The measurement will be stored as a signed 64-bit integer with the tag
.B measurement.
The time of the measurment in microseconds will be stored (duplicated) in
.B timestamp_from
and
.B timestamp_to.
.PP
.Bl -tag -width -indent
.It vm_calibration=FLOAT
Factor to calibrate the readings, defaults to 1.124.

.It vm_channel={1|2}
Which channel to use on two-channel devices.

.It vm_message_topic=TOPIC
MQTT topic to apply to generated messages.
.El
.PP
.SS averager (PA)
The averager module reads point measurements from it's senders and produces average measurments over a given timespan and
at a given rate. Other messages are simply passed through.
.PP
The averager module expects to find the tag
.B measurement
in array messages from it's senders. It will generate average measurements with the following values as unsigned 64-bit integers:

.Bl -tag -width -indent
.It average
The average of the measurements received in the timespan.
.It max
The maximum value of all the measurements received in the timespan.
.It min
The minimum value of all the measurements received in the timespan.
.It timestamp_from
The lowest timestamp of all the measurements received in the timespan.
.It timestamp_to
The highest timestamp of all the measurements received in the timespan.
.El
.PP
The following configuration parameters are available in the
.B avarager
module:
.PP
.Bl -tag -width -indent
.It avg_timespan=SECONDS
How long timespan to average over. Defaults to 15 seconds.

.It avg_interval=SECONDS
How often to produce average calculations. Defaults to 10 seconds.

.It avg_preserve_points={yes|no}
Preserve individual measurements and put them in output buffer. Defaults to no.

.It avg_discard_unknowns={yes|no}
Delete messages which are not point measurements and information messages. Defaults to no, which means to simply forward them.

.It avg_message_topic=TOPIC
MQTT topic to apply to generated messages and any forwarded point messages.
.El
.SH COMMON CONFIGURATION PARAMETERS
Replace the
.B X
with the configuration paramenter prefix of the module.
.PP
.SS cmodule parameters
.Bl -tag -width -indent
.It X_workers=UNSIGNED INTEGER
How many worker fork copies to spawn. If multiple forks are used, incoming messages will be given to
the fork having the least amount of messages waiting to be processed. Note that if sourcing is used,
each for will source messages according to given parameters. Defaults to 1, maximum is 16.

.It X_source_interval_ms=MILLISECONDS
How many milliseconds to wait between each call of the source function. Defaults to 1000, one second.

.It X_log_prefix=PREFIX
Set a custom log prefix to be prepended to any log messages printed out. Use the RRR_MSG_x and RRR_DBG_x (x is a number)
macros to print messages like the reset of RRR does.

.It X_drop_on_error={yes|no}
If there is an error during processing of a message, just drop it instead of restarting the program.
Defaults to no.
.El
.SS TLS parameters
.Bl -tag -width -indent
.It X_tls_certificate_file=FILENAME
The certificate to use for TLS connections. Optional for clients, required for servers.

.It X_tls_key_file=FILENAME
The private key to use for TLS connections. Optional for clients, required for servers.

.It X_tls_ca_path=PATH[:OTHER_PATH...]
An alternative directory in which to search for CA certificates used when validating certificates. Debuglevel 1 will expose the actual search path. Optional.

.It X_tls_ca_file=FILENAME
A CA certificate file to use when validating certificates. Optional.
.El
.SH CONVERSION METHODS
The list below describes the conversion methods available in the
.B mangler (PA)
module.

Note that
.B blob2*
and
.B str2*
may accept compatible types depending on configuration.

\(bu Types compatible with
.B blob : blob, sep, msg, str

\(bu Types compatible with
.B str : str, sep, stx

.TP 10
.B h2str
Converts any numbers to strings. If an array field contains multiple values, the resulting strings will be space-prefixed to a total length of 20 characters.

.TP 10
.B h2vain
Converts integer types which are zero to vain.

.TP 10
.B blob2str
Converts blob or blob-ish fields to strings. No data manipulation is performed.

.TP 10
.B blob2blob
Converts blob or blob-ish fields to blobs. No data manipulation is performed.

.TP 10
.B blob2hex
Converts blob or blob-ish fields to hexadecimal ASCII stored in str types. The output size will be exactly double the input size. 

.TP 10
.B str2str
Converts str or str-ish fields to strings. No data manipulation is performed.

.TP 10
.B str2blob
Converts str or str-ish fields to blobs. No data manipulation is performed.

.TP 10
.B str2h
Converts str or str-ish fields to numbers, if possible.
Input numbers may be prefixed with spaces.
Unsigned are used unless one or more values are negative, in which case all values of the fields will be signed.
Overflow is not handled, and numbers may become truncated.

.TP 10
.B str2vain
Converts str fields which are empty to vain.

.TP 10
.B msg2blob       
Converts msg fields to blobs. No data manipulation is performed.

.TP 10
.B vain2h
Converts vain fields to unsigned integers with value 0.

.TP 10
.B vain2str
Converts vain fields to empty str fields.

.TP 10
.B hchar2str
Treats any numbers as characters and stores them in a string value.
The value of any numbers may not exceed 255.
If an array value has multiple elements, all of their corresponding characters will be concatenated into a single string value.

.PP
.SH SEE ALSO
.Xr rrr(1),
.Xr rrr_post(1),
.Xr rrr_stats(1),
.Xr rrr_msg(1),
.Xr rrr_python3(5)
