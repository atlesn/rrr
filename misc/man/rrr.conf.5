.Dd 2020-08-23
.TH RRR.CONF 5
.SH NAME
Read Route Record is a dynamic module-based message handling program
for collecting, buffering, processing and storing messages and measurements.
.SH DESCRIPTION
The
.B rrr
environment is set up with a configuration file. The file specifies any number
of
.B instances
of different
.B modules.
The different instances either get messages from other
modules or read them externally. Some also save messages externally or
send them over the network.
.PP
Instances are linked to each other using the 
.B senders=instance1,...
configuration parameter, which tells the instance which other modules to get messages from. A
.B source
module is a module which cannot read from other modules, and this argument should
not be specified.
.PP
At program startup, the order of module start can be controlled using the
.B wait_for=instance_1,...
configuration parameter. The instance with this argument will not be started until the
other specified instances have started.
.PP
.B rrr
may be extended with custom modules. Custom functionality may also be achieved by
using a module which can send data to and from a python program.
.PP
.B rrr
automatically restarts all running instances in case one instance for any
reason stops or hangs, like due to network problems. A failing instance
usually does not make
.B rrr
quit, all instances are simply restarted.
.PP
.SH SYNTAX
Any number of instances may be specified. An instance specification begins with a [] containing
the user chosen name of the instance. A module to use must then be specified, along with
module-specific settings. The
.B senders=
setting is mandatory for modules which read from other modules, but invalid for modules
which are sources (see MODULES section). An instance section ends when a new begins
or when we reach the end of the file.
.PP
.nf
# Comment are like this, they must be on separate lines. The instance name
# and module name are the ony parameters which are always required. Spaces
# around the = are ignored as well as spaces at the end of a line.

# User chosen name of the instance
[INSTANCE_1_NAME]
# Which module to use for the instance
module={MODULE NAME}

# Which other instances to read from (not for source only modules)
senders=INSTANCE NAME,...

# On program startup, wait for these instances to start before starting (optional)
wait_for=WAIT FOR,...

# Drop all messages from senders which do not match the set topic (optional)
topic_filter=MQTT TOPIC FILTER

# Module-specific arguments (module-dependant)
argument1 = value1

[INSTANCE_2_NAME]
module=...

# Any number of named array trees may be specified
# Modules parsing array data may refer to these instead of having them defined inside each instance block
{ARRAY_TREE_DEFINITION_A}
be1#type,be1#one
IF ({type} == 1)
	;
ELSIF ({type} == 2)
	be2#two
	;
ELSIF ({type} > 0)
	blob{type}#x
	;
ELSE
	err
	;
sep1#separator
;
.fi
.PP
If an instance is specified as sender in more than one other instance, these will compete about messages from it.
Use the
.B buffer
module and enable duplication if a message is to be processed by multiple modules,
for instance when different modules should process messages with different topics.
Instances may not use themselves as senders.
.PP
Named array tree definitions begin with {NAME} and end with a semicolon.
In all module parameters for array definitions, it is possible to instead specify {NAME} to reference a definition
from configuration file. This is useful for more complex trees which are messy to write on a single line.
Array tree definitions may be defined above or below where they are used.
See
.Xr rrr_post(1)
for array tree syntax, and in the chapters of each module below on where they can be used.
.SH MESSAGES
A message consists of at least a timestamp (in microseconds) and either arbitary data or
and array of values. Messages may in addition contain an MQTT topic which can be used internally by certain modules.
.PP
Messages can either contain arbitary data or a data array.
.PP
Modules which support parsing data arrays from externally or from other modules might require a list of expected data
types to be specified in their configuration. If the total size of the input does not match the received input, parsing
of the message will fail. Some modules also generate array messages internally, and they can be created within Perl and
Python scripts. Fields from an HTTP request can be mapped into an array, and an array can be mapped into database columns.
.PP
The general syntax for an array parsing specification (without branches) is a comma separated list of types with length and item count specifications. 
.PP
.DlÂ type1[length1][@count1][#tag1][,type2[length2][@count2][#tag2]][,...]
.PP
The arrays are special as it is possible to have multiple values at each position. Each position has one or more values
of the exact same type and length, and may or may not have a tag (string name) identifying the particular position. Tag
names are also not unique, multiple positions may have the same tag name also with different types.
.PP
The reason for having this "2D" like structure is to group data together when receiving in such a way that it is easy
to find the different values afterwards.
.PP
Below follows a graphical representation of an array with many values. Note that there for demonstration purposes
are two values named
.B same_tag,
and that the eight byte sequence with ASCII-characters is split into two values. The string type may be of any length
enclosed by quotes "". The quotes will be removed when the value is parsed. At the second array position, there are nine
values, and at the sixth position there are two values.
.PP
.nf
+--------+-----------------+---------------------------+----------+----------+-------------+----+
| my_int |   my_integers   |                           | same_tag | same_tag | split_blob  |    |
|   1    |1|2|3|4|5|6|7|8|9| "String data without tag" |    11    |    12    | blob | abcd | CR |
+--------+-----------------+---------------------------+----------+----------+-------------+----+
.fi
.PP
An array parsing specification to produce a dataset like this (assuming the integers are 1 byte wide):
.PP
.Dl be1#my_int,be1@9#my_integers,str,be1#same_tag,be1#same_tag,blob4@2#split_blob,sep1
.PP
Refer to the
.B ARRAY DEFINITION
section of
.Xr rrr_post(1)
for the complete specification of all the types, and the specification for array trees (branching with IF-blocks).
.SS IP MESSAGES
Some messages contain IP data, for instance messages created by a module which reads from the network. The address
of the sender will be contained within the message. All modules may use IP-messages, but not all of them use the IP-data. 
.SH MODULES AND CONFIGURATION PARAMETERS
.PP
Modules have different special capabilites, denoted by the following letters. The actual implementation may
vary between modules. Many modules can despite this handle all types of messages, more or less ignoring their contents.
.PP
.Bl -tag -width -indent
.It S
Source module, can't read from other modules
.It P
Processor module, can have senders specified to read from (set with
.B senders=
) and may also be read from by other modules
.It D
Dead-end module, can only read from other modules
.It N
Network-oriented module, cannot be used as sender nor have senders specified itself.
.It A
Module supports data arrays (see above)
.It I
Module supports IP messages
.El
.PP
All modules support array and/or IP-messages, also those who do not have  
.B A
or
.B I
specified. Array- and IP-capable modules may however use or modify data from such messages.
Messages may have both IP- and Array-data simultaneously. 
.PP
The following modules are available, they are discussed in detail further down.
.PP
.Bl -tag -width -indent
.It dummy (S)
Dummy module which generates messages.

.It raw (PAI)
Dumps messages, used for debugging.

.It ip (PAI)
Handles IP communication, UDP and TCP.

.It buffer (P)
Buffers messages, may be used to duplicate messages to multiple readers.

.It ipclient (PI)
Implements the RRR assured single delivery protocol on UDP for unstable connections.

.It python3 (PAI)
Processes and generates messages with custom Python3 scripts.

.It perl5 (PAI)
Processes and generates messages with custom Perl5 scripts.

.It cmodule (P)
Processes and generates messages with custom C modules.

.It socket (SA)
Creates a socket to which other programs or
.Xr rrr_post(1)
can deliver data.

.It httpserver (PAI)
Spins up a TLS-capable HTTP server which can parse POST and GET data into RRR message arrays.

.It httpclient (PAI)
Sends records to any HTTP server using GET or POST, TLS-capable.

.It mqttbroker (N)
A TLS-capable V5/V3.1(.1) MQTT broker supporting TLS, authentication, ACL.

.It mqttclient (PA)
Subscribes to MQTT topics and/or publishes messages. TLS-capable V5/V3.1(.1) MQTT client.

.It journal (SA)
Traps log messages from all modules and saves them into RRR messages.

.It file (SA)
Reads from files, sockets, character devices and FIFO pipes.

.It mysql (DAI)
Saves records to a MySQL or MariaDB table.

.It influxdb (DA)
Saves data to an InfluxDB database.

.It voltmonitor (SA)
Reads from a USB voltmeter.

.It averager (PA)
Collects point measurements and calculates average values.
.El
.SS dummy (S)
This module constantly generates empty messages, optionally containing some dummy data.
.PP
The following configuration parameters are available in the
.B dummy
module:
.PP
.Bl -tag -width -indent
.It dummy_no_generation={yes|no}
No messages are generated, defaults to yes. 
.It dummy_no_sleeping={yes|no}
Don't sleep between creating messages, but create as many messages as the reader can handle. Defaults to no.
.It dummy_max_generated={unsigned number}
Stop generating messages after this number is reached. 0 value or not defined means that generation will never stop.
.It dummy_random_payload_max_size={BYTES}
When generating messages, give them an empty payload with a random size in the range 0 to BYTES. Default is 0 (no payload for messages).
.It dummy_topic={TOPIC}
Set an MQTT topic in generated messages.
.El
.SS raw (PAI)
This module simply drains data from it's senders and deletes it after printing a message if debugging is active. It
can read from both IP modules and non-IP.
.PP

.Bl -tag -width -indent
.It raw_print_data={yes|no}
Print the timestamp of each received message and dump any arrays present in the messages. The global debuglevel 2 must
be set for messages to actually be printed. This to avoid problems with the journal module.
.El
.SS ip (PAI)
This module is capable of listening on an UDP or TCP port and read messages or arrays, as well as sending data to remote hosts.
A message is created for each received packet and a timestamp is added.
If the received data does not match the specified data array, the packet is dropped.
.PP
If an instance is configured to wait for this module before starting, the we will set up any listening sockets before the
waiting instance is started.
.PP
The following configuration parameters are available in the
.B ip
module:
.PP
.Bl -tag -width -indent
.It ip_udp_port=LISTEN PORT
.It ip_tcp_port=LISTEN PORT
Port to listen on on udp or tcp. Udp  is also source port for outbound messages. Range is 1-65535, default value is 0 which means we don't listen.
If left unspecified, no listening takes place.

.It ip_input_types=ARRAY DEFINITION
Specification of expected data to receive from remote. See
.Xr rrr_post(1)
for the syntax. No listening takes places unless this is specified.
To receive RRR messages, simply set the definition to
.B msg
and set
.B ip_extract_rrr_messages
to
.B yes.

.It ip_extract_rrr_messages={yes|no}
Extract any RRR messages from the received data (if specified in ip_input_types) and save them in the buffer for other modules to pick up.
Causes any other data in the received arrays to be dropped.
If set to yes and no message field is specified in the array definition, an error will be produced.
Defaults to no.

.It ip_max_message_size=BYTES
Maximum size of a message when reading. This should be set to prevent messages with missing delimeters to fill up memory.
A value of 0 means unlimited message size.
Defaults to 4096.

.It ip_default_topic=MQTT-TOPIC
An optional MQTT topic to set on the generated messages.

.It ip_sync_byte_by_byte={yes|no}
If array parsing fails according to definition, keep skipping one byte forward in the stream until a match is found.
Defaults to no, which means to only sync on boundaries of incoming messages.

.It ip_send_rrr_message={yes|no}
If set to yes, complete RRR messages encoded for network will be sent.
If set to no or left unset, messages with arrays will have their array packed and sent, and messages with other data will simply have their contents sent as is.

.It ip_preserve_order={yes|no}
Attempt to send messages in order according to their timestamp.
Messages to a particular destination will be sent in order according to their creation timestamp.
If messages time out before they are sent, order is guaranteed for the remaining messages in the queue although some are missing.
This will impact performance when destinations are unreachable.
Defaults no no.

.It ip_send_multiple_per_connection={yes|no}
In one send iteration (a very short timespan), allow multiple messages to be sent on a single connection.
In low traffic conditions this parameter has no practical effect.
Defaults to no, which enforces only one message per connection.

.It ip_persistent_connections={yes|no}
After a packet is sent, don't close the TCP connection but re-use it later for more messages. Implies
.B ip_send_multiple_per_connection
if set to yes. Defaults to no.

.It ip_send_timeout=SECONDS
If messages are not successfully sent within this time, perform the action specified in
.B ip_timeout_action.
Default is not timeout (same as 0).

.It ip_smart_timeout={yes|no}
If set to yes and a message is successfully sent, reset the timeout counter for all other unsent messages destined for the same host, port and protocol currently in the queue.
If set to no, unsent messages will time out according to the current send timeout regardless of whether other messages to the same destination have been sent or not in the meantime.
Defaults to no. 

.It ip_timeout_action={retry|drop|return}
What do do when a message times out after being undeliverable. In case of
.B retry,
keep trying indefinitely (default).
.B drop
will cause the message to be dropped, and
.B return
will put the message into output queue for readers to pick up. The latter is useful if an application for instance wishes to change
the destination address if the target host is unreachable, and possibly log errors. If
.B retry
is used, then
.B ip_send_timeout
must be set to zero or left undefined. 

.It ip_graylist_timeout_ms=MILLISECONDS
If a TCP destination is unreachable, add it to the graylist and retry only after the specified  number of milliseconds has passed.
Defaults to 2000 ms. A value of zero disables graylisting, and causes a high rate of connection attempts to unreachable destinations.

.It ip_ttl_seconds=SECONDS
Check the creation timestamp of messages and drop them if they are or become older than the specified amount of seconds.
The TTL check is not the same as the send timeout, it does not respect
.B ip_timeout_action
nor
.B ip_smart_timeout.
TTL expiration also applies to partially sent messages.
Defaults to 0 which means that TTL check is disabled.   
 
.It ip_target_host=HOST
.It ip_target_port=PORT
.It ip_target_protocol=PROTOCOL
Default target host, port and protocol for messages from other modules which do not contain address information.
If left unset and we recevie messages which do not contain address information, the messages are dropped
and warning messages are produced. Protocol may be udp or tcp, defaults to udp.

.It ip_force_target={yes|no}
Use the specified target host and port even if messages contain other address information. Default is no.

.It ip_array_send_tags=tag1[,tag2[,...]]
Look for the defined tags in array messages from other modules, and send these concatenated together to remote.
If this option is specified and a received message is not an array or does not have all of the tags defined,
the message is dropped and an error message is produced.
If this option is left unspecified, all values from arrays are sent, and messages which are not arrays will have their raw data sent if any.
.El
.PP
.SS buffer (P)
The buffer collects all messages from all senders and wait for them to be collected by other instances.
.PP
.Bl -tag -width -indent
.It buffer_ttl_seconds=SECONDS
Any message received with timestamp older than the specified amount of seconds will be dropped. Useful in situations
where messages circulate between modules.

.It buffer_do_duplicate={yes|no}
If set to yes, incoming messages will be duplicated so that one copy is received by every reader. If set to no,
the readers will compete over the messages. Defaults to no. 
.El
.SS ipclient (PI)
The ipclient module collects any messages from senders and sends them over the network to another 
.B RRR
environment's ipclient module using UDP. It may also accept connections from other clients and receive data,
or a combination of these. An underlying UDP stream protocol ensures single delivery of
all messages (similar design as MQTT QOS2), and messages are checksummed with a CRC32 algorithm.
.PP
.B ipclient is not secure in any way and must only be used on closed networks!
.PP
After an ipclient instance has connected to a remote ipclient, the remote will accept packets, and the connection
persists even if the connecting clients IP-address changes unless specified otherwise in the configuration.
.PP
Please note that ipclient is not designed to receive connections and packets from arbitary remote hosts.
If a remote sends packets and does not complete the acknowledgement handshakes, the packets will persist in memory.
.PP
If a remote host becomes unavailable for a longer period of time, unfinished acknowledgement handshakes
are re-initiated when it becomes available again, even if it has been re-started in the mean time.
.PP
ipclient will not accept incoming connections from other clients unless explicitly told to in the configuration file.
.PP
The following configuraton parameters are available in the
.B ipclient
module:
.PP
.Bl -tag -width -indent
.It ipclient_client_number=NUMBER
Each ipclient instance in a set of instances which communicate together must have a unique ID number in the range 1-4294967295.
If you have two instances running, set one of them to 1 and the other one to 2.

.It ipclient_default_remote=REMOTE NAME OR ADDRESS
The name or address of the client which we send packets without address information to.

.It ipclient_default_remote_port=PORT NUMBER
The port number of the default remote, defaults to 5555.

.It ipclient_src_port=PORT NUMBER
Source port used for sending and receiving packtes, defaults to 5555.

.It ipclient_listen={yes|no}
Accept incoming connections if set to yes. Default is no.

.It ipclient_disallow_remote_ip_swap={yes|no}
If yes and a remote changes its IP-address, RRR must restart before the new address can be accepted. Default is no. 
.El
.SS python3 (PAI)
This module can send messages to a custom python program and read them back.
All messages read from the senders are sent to the python program to the process function specified.
A read-only source function may also be specified if the python program should only generate messages by itself and not receive any.
It is possible to specify both source- and process-functions at the same time.
Functions should return 0 on success and put any messages into the result class provided in the argument.
If something goes wrong, the functions can return 1 or raise an exception which makes RRR stop all running instances and restart.
.PP
The RRR module should be imported by the custom python program, but is in only available when the python script is called from RRR.
.PP
The following configuration parameters are available in the
.B python3
module:
.PP
.Bl -tag -width -indent
.It python3_module=MODULE NAME
The module name for the python3 program to be executed. Imported by 'from MODULE NAME import *'

.It python3_module_path=MODULE NAME
An extra path in which to search for the module.

.It python3_source_function=FUNCTION NAME
The name of the source function in the python program which we read from continously.

.It python3_process_function=FUNCTION NAME
The name of the processing function in the python program which we send packets from other modules to. We also read any messages sent back.

.It python3_config_function=FUNCTION NAME
The name of the function in the python program to which we send settings form the configuration file.
All settings defined inside the python block in the configuration file are sent in here.

.It CUSTOM SETTING=VALUE
Any number of custom settings for the python program might be set as needed.
.El
.PP
Refer to the
.B cmodule
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of the following parameters:
.PP
.Bl -tag -width -indent
.It python3_source_interval_ms=MILLISECONDS
.It python3_sleep_time_ms=MILLISECONDS
.It python3_nothing_happend_limit=UNSIGNED INTEGER
.It python3_log_prefix=PREFIX
.It python3_drop_on_error={yes|no}
.El
.PP
Below follows an example python message processing and generating program. A socket is used to
post messages. The process and source functions have their own environments, and they will not
share any global variables set by the config function. The config function is called first in
the process environment, then in the source environment.
.PP
.nf
from rrr_helper import *
import time

my_global_variable = ""

def config(rrr_config : config):
	global my_global_variable

	# retrieve a custom setting from the configuration file. The get()
	# will update the "was-used" flag in the setting which stops a
	# warning from being printed.
	print ("Received configuration parameters")
	my_global_variable = config.get("my_global_variable")

	return True

def process(socket : rrr_socket, message: rrr_message):
	# Return False if something is wrong
	if my_global_variable == "":
		print("Error: configuration failure")
		return False
		
	# modify the retrieved message as needed
	message.timestamp = message.timestamp + 1
	
	# queue the message to be sent back (optional) for python to give to readers
	socket.send(message)
	
	return True

def source(socket : rrr_socket, message : rrr_message):
	# Set an array value in the template message
    my_array_value = rrr_array_value()
    my_array_value.set_tag("my_tag")
    my_array_value.set(0, "my_value")

    my_array = rrr_array()
    my_array.append(my_array_value)

    message.set_array(my_array)

	# queue the message to be sent back (optional) for python to give to readers
	# skip this step if the message are not to be sent, it is then simply discarded
	# may be called multiple times with the same message
	socket.send(message)
	
	# sleep to limit output rate
	time.sleep(1)

	return True
	
.fi
More details about Python in 
.Xr rrr_python3(5)
.PP
.SS perl5 (PAI)
The perl5 module makes it possible to process and generate messages in a custom 
perl script. The first and only argument to the source- and generate-functions
is the RRR message in the form of a hash with different parameters which may be
modified as needed. To pass the message back to RRR, the
.B send()-method
of the message must be called. If the message should not be passed on, simply skip
the call to this method. The method may be called multiple times if required.
.PP
It is possible to work with RRR array messages in the Perl script. This is done
through calling dedicated functions on the message object received by source and
process functions. The functions available are listed in the example scripts with comments.
More details about types are found in 
.Xr rrr_post(1)
.PP
The following configuration parameters are available in the
.B perl5
module:
.PP
.Bl -tag -width -indent
.It perl5_file=FILENAME
Path and filename of the perl script to use. The script is run once when the program starts,
which means that code may be added outside the three subroutines mentioned below.

.It perl5_source_interval=MILLISECONDS
How long to wait between each call of the source subroutine (if defined). Defaults to 1000 ms.

.It perl5_source_sub=SUBROUTINE NAME
Optional name of a subroutine which receives an rrr::rrr_helper::rrr_message object and modifies
it to generate a new message. Called at specified interval.

.It perl5_process_sub=SUBROUTINE NAME
Optional name of a subroutine which receives an rrr::rrr_helper::rrr_message object from the senders
of the current instance. The message may be modified or left alone.

.It perl5_config_sub=SUBROUTINE NAME
Optional name of a subroutine which receives an rrr::rrr_helper::rrr_settings object when the program
is started. Any settings from the instance definition in the configuration file can be read from
this object, also custom settings. Settings may also be modified and new settings can be added. The
settings object may also be stored in the script to be read from or modified from the source- and 
generate-subroutines.

.It CUSTOM SETTING=VALUE
Any number of custom settings for the Perl script might be set as needed.
.El
.PP
Refer to the
.B cmodule
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of the following parameters:
.PP
.Bl -tag -width -indent
.It perl5_source_interval_ms=MILLISECONDS
.It perl5_sleep_time_ms=MILLISECONDS
.It perl5_nothing_happend_limit=UNSIGNED INTEGER
.It perl5_log_prefix=PREFIX
.It perl5_drop_on_error={yes|no}
.El
.PP
.B NOTE:
Any modified settings will currently not be visible in the perl5 RRR module, only in the perl5 script.
.PP
There must always be either a source- or process subroutine specified, or both. If a process subroutine
is specified, there must also be at least one sender specified.
.PP
If a Perl instance receives messages from an IP-capable module, like
.B udp,
the address information of the original sender of a message is retained. Other IP-capable modules may
then use this information if they read data from the Perl instance, for example if you wish to use
a Perl script to generate a reply message to some remote host. There is no high-level method for modifying
the address information inside the Perl script, but the values
.B ip_addr
and
.B ip_addr_len
are to be found in the message hash. The values are filled with data from
.B struct sockaddr
and
.B socklen_t
which is provided by the operating system. These two values may be saved and re-used in later messages,
or they may be modified if you know how to do that (not documented here).
In addition,
.B ip_so_type
can be either "udp" or "tcp" to describe a protocol type. Some modules may use this parameter. It can also be empty.
.PP
The IP information in a message can be accessed and modified through helper functions. IPv4 and IPv6 both work
with these transparently.
.PP
.Bl -tag -width -indent
.It my ($ip, $port) = $message->ip_get();
Get IP (as text) and port from the message. Returns undefined if there is no IP information in the message.
.It $message->ip_set($ip, $port);
Set IP and port in a message. The $ip is in string representation (like 2a0a::1 or 4.4.4.4). Returns 1 on success and 0 on failure.
.It $message->ip_clear();
Delete IP information from a message. Always returns 1.
.El
.PP
The following additional parameters are available in the rrr_message hash reference:
.Bl -tag -width -indent
.It topic
The MQTT topic of the messsage.
.It timestamp
The timestamp of the message.
.It data
The raw data of the message (ignored when array is being used). Updates to the message array will not affect this field, but data
will be cleared if the message is sent with array fields set.
.It data_length
The length of the data.
.It type_and_class
Type and class of message, for internal use.
.El
.PP
The
.B rrr_debug
class can be used to print out debug messages just like RRR does internally. Use these instead of perl print functions
if you wish to have your program output messages in a tidy controlled fashion. There are three different functions in this class:
.PP
.Bl -tag -width -indent
.It msg(level, message)
Messages to this function are always printed prefixed with the specified loglevel (a number 0, 1, 2 etc.).
.It dbg(level, message)
Messages to this function are printed only if the specified loglevel (debuglevel) is active. If loglevel is 0 however,
the message is always printed.
.It err(message)
Messages to this function are always printed with loglevel 0 and to STDERR output. Do not overuse this as it might
cause broadcast messages on the system when RRR is run for instance by systemd. Error messages should usually be
printed using the
.B msg
function with loglevel 0.
.El
.PP
A variable must be blessed with the
.B rrr_debug
class to use the debug functions, look at the code below on how to do this. There are also commented out example
calls to message print functions. 
.PP
Below follows an example perl script.
.PP
.nf
#!/usr/bin/perl -w

package main;

use rrr::rrr_helper;
use rrr::rrr_helper::rrr_message;
use rrr::rrr_helper::rrr_settings;
use rrr::rrr_helper::rrr_debug;

my $debug = { };
bless $debug, rrr::rrr_helper::rrr_debug;

my $global_settings = undef;

sub config {
	# Get the rrr_settings-object. Has get(key) and set(key,value) methods.
	my $settings = shift;

	# If needed, save the settings object
	$global_settings = $settings;

	# Custom settings from the configuration file must be read to avoid warning messages
	# $debug->msg(1, "my_custom_setting is: " . $settings->get("my_custom_setting") . "\\n");

	# Set a custom setting
	$settings->set("my_new_setting", "5");

	# Return 1 for success and 0 for error
	return 1;
}

sub source {
	# Receive a newly generated template message
	my $message = shift;

	# Do some modifications
	$message->{'timestamp'} = $message->{'timestamp'} - $global_settings->get("my_custom_setting");

	# $debug->msg(1, "source:  new timestamp of message is: " . $message->{'timestamp'} . "\\n");

	# Pass on the new message
	$message->send();

	# Return 1 for success and 0 for error
	return 1;
}

sub process {
	# Get a message from senders of the perl5 instance
	my $message = shift;

	# Do some modifications to the message
	$message->{'timestamp'} = $message->{'timestamp'} - $global_settings->get("my_custom_setting");

	# $debug->msg(1, "process: new timestamp of message is: " . $message->{'timestamp'} . "\\n");

	# NOTE ! To understand how message arrays work, look in the MESSAGES section in the
	# man page of rrr.conf for a graphical representation (furter up if you're already in the man page).

	# An RRR array consits of several positions which each may have one or more value of a certiain
	# type and length. A position may or may not have an identification tag, and several positions
	# may have the same tag. An RRR message either contains raw data of some sort or an RRR array.

	# If array values are pushed to the message in a Perl5 script, any data in the message
	# will not be forwarded.

	# Push some values of dirrent types onto the message array. Since
	# we use the same tag name "tag" for many values, multiple values
	# with the same tag will exist within the array.
	$message->push_tag_blob ("tag", "blob", 4);
	$message->push_tag_str ("tag", "str");
	$message->push_tag_h ("tag", 666);
	$message->push_tag_fixp ("tag", 666);

	# Set some integer values
	my @my_integers = (1, 2, 3, 4);

	# The following function will accept both array values and other values.
	# If an array reference is passed, like here, the values will be added
	# to the same tag. If they are strings, their length -must- be equal.

	# If different length strings are required, push them into separate
	# tags like above. The RRR type is chosen based on the first value
	# in the array, type h (host endian integer) will be chosen here.
	$message->push_tag ("tag", \@my_integers);

	# This will get all matching values for a particular tag. Regardless
	# of wether duplicate tags have more than one element in the or not,
	# they will all be put into the same result array. Here, all the values
	# added above (four added one by one and four from the array) will
	# be put into @values_result which will end up having eight elements.
	my @values_result = $message->get_tag ("tag");

	# The set_* functions will delete all matching tag names from the array
	# and then push the new value. The type of any existing does not matter,
	# all tags with matching tag name in the array will be removed.
	$message->set_tag_blob ("tag", "blob", 4);
	$message->set_tag_str ("tag", "str");
	$message->set_tag_fixp ("tag", 666);
	$message->set_tag_h ("tag", 1);

	# It is allowed to have empty tag names, just use "" as tag
	$message->set_tag_h("", 0);

	# Since set_tag_h is the last value, the number '1' is the only
	# element in the array now with the tag "tag". The get_tag_all
	# function will otherwise retrieve all values at all matching tags.
	my @array_with_only_one_value = $message->get_tag_all ("tag");

	# It is possible to retrieve a particular element at a certain position
	# if the position of a value is known. Since we know there is a
	# number with the tag "tag" in the array, we can get the first element
	# returned.
	my $value = ($message->get_tag_all("tag"))[0];

	# These two functions returns arrays containing the tag names
	# at each array position, or the value count at each position. If
	# there is no tag name at a position, an empty "" value is returned.
	# All array position always has at least one element.
	print "Tag names: " . join(",", $message->get_tag_names ()) . "\n";
	print "Tag counts: " . join(",", $message->get_tag_counts ()) . "\n";

	# Get all values at a particular position
	print "Get a position: " . join (",", $message->get_position(0)) . "\n";
	print "Array position count: " . $message->count_positions() . "\n";

	# This will clear all values from the array
	$message->clear_tag("tag");

	# Pass on the modified message
	$message->send();

	# Return 1 for success and 0 for error
	return 1;
}
.fi
.SS cmodule (P)
This module allows usage of custom cmodules (C-modules) in a simplified framework. To use this, a module must first be
written in the RRR source in the directory /src/cmodules/ and then compiled (just compile RRR as usual and
directions will be given). There is an example file with appropriate licenses in the cmodules directory
which may be used as a template for custom cmodules.
.PP
RRR will deal with communication with other modules and many other tasks, which makes it simpler to write a
cmodule than to write a native RRR module.
.PP
All custom cmodules will be run in separate forks.
.PP
The following confgiuration parameters are available in the
.B cmodule
module: 
.PP
.Bl -tag -width -indent
.It cmodule_name=NAME
The name of the cmodule. If the name is
.B dummy,
RRR will look for the module
.B dummy.so
and the source file for this module should be called
.B dummy.c.

.It cmodule_config_function=NAME
The function to which to pass configuration parameters, called at program startup. Optional.

.It cmodule_source_function=NAME
The function to which to call to source new messages. Optional, but at least one of source and processor must be set.

.It cmodule_process_function=NAME
The function to which to call to process messages from senders. Optional, but at least one of source and processor must be set.

.It cmodule_cleanup_function=NAME
The function to call before the program shuts down. Optional.

.It CUSTOM SETTING=VALUE
Any number of custom settings for the C-module might be set as needed.
.El
.PP
Refer to the
.B cmodule
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of the following parameters:
.PP
.Bl -tag -width -indent
.It cmodule_source_interval_ms=MILLISECONDS
.It cmodule_sleep_time_ms=MILLISECONDS
.It cmodule_nothing_happend_limit=UNSIGNED INTEGER
.It cmodule_log_prefix=PREFIX
.It cmodule_drop_on_error={yes|no}
.El
.PP
The source and process functions receives a new message which of they must manage the memory. The message must
either be passed on to other modules by calling
.B rrr_send_and_free(...)
or be freed (if the message is to be discarded) by calling
.B rrr_free(...).
A message, if it must be sent several times, may be duplicated by using.
.B rrr_message_duplicate(...).
.PP
Please refer to the source code on how these functions work. Some headers which
might be useful when working with for instance array messages are included in /src/cmodules/cmodule.h .
It is not a priority at this time to document these, but they are easy to use and usage examples are to
be found throughout the RRR source code (which is human- and machine readable).
.PP
Functions must return 0 on success and 1 if there are errors.  
.SS socket (SA)
The socket module listens on a UNIX socket for RRR messages or custom data records.
.PP
The following configuration parameters are available in the
.B socket
module:
.PP
.Bl -tag -width -indent
.It socket_path=FILENAME
Path and file name to use for the socket. The file cannot exist when the program starts.

.It socket_unlink_if_exists={yes|no}
If set to yes and the socket defined in `socket_path` exists when we start, unlink it. If set to no, we produce an error if
the socket exists. Defaults to no.

.It socket_default_topic=MQTT-TOPIC
An optional MQTT topic to set on the generated messages.

.It socket_receive_rrr_message={yes|no}
If set to 
.B yes
, complete RRR messages are expected to be received on the socket. No array definition is to be specified. 
.Xr rrr_post(1)
may generate such messages. If set to 
.B no
, an array definition must be specified, and RRR array messages will be produced from the received data. Defaults to no.

.It socket_input_types=ARRAY DEFINITION
Format of data received on the socket, see
.Xr rrr_post(1)
for syntax.

.It socket_sync_byte_by_byte={yes|no}
If array parsing fails according to definition, keep skipping one byte forward in the stream until a match is found.
Defaults to no, which means to only sync on boundaries of incoming messages.
.El
.SS httpserver (PAI)
This module accepts connections from HTTP clients, extracts POST or GET data fields and puts it into RRR array messages
for other modules to use. The query string from the URI is parsed in both GET and POST requests. Duplicate field names are allowed.
.PP
.B DO NOT USE
this HTTP server openly on the Internet. It has
.B NO PROTECTION MECHANISMS
against DoS attacks, flooding etc. There is also
.B NO AUTHENTICATION.
Use a server like Apache to run a public server.
.PP
This module does not respond with any data (unless raw modes are used). If a request was successfully processed, a
.B 204 No Content
response is returned to the client. If there was any errors,
.B 400 Bad Request
or
.B 500 Internal Server Error
response may be returned.
.PP
Depending on the configuration, an incoming HTTP request may result in zero, one or two RRR messages to be generated:
.PP
.Bl -tag -width -indent
.It RRR array message with fields
Any configured fields from GET, POST or query string in the endpoint are put into an RRR array message.
If full request receive is active, fields generated here will be put into the same message. Array messages will have the topic
.B httpserver/request/uuu
set, where
.B uuu
is a unique ID. Configured fields are not retrieved for requests with the
.B OPTIONS
method. 

.It RRR message with raw data
If raw data receive is active, a separate RRR message will be generated for this.
This message is not an RRR array message.
Raw data messages will have the topic
.B httpserver/raw/uuu
set, where
.B uuu
is a unique ID.
.El
.PP
If both message types are generated by a single HTTP request, the unique ID fields in the topics will be identical.
The IDs are unsigned desimal numbers which increase by 1 for every received request, also if they do not cause any RRR
messages to be generated. 
.PP
The following configuration parameters are available in the
.B httpserver
module:
.PP
.Bl -tag -width -indent
.It http_server_transport_type={tls|plain|both}
Listen with TLS mode, plaintext mode or both. Defaults to 'plain'.

.It http_server_port_tls=PORT
Port to use for TLS listening, defaults to 443.

.It http_server_port_plain=PORT
Port to use for plaintext listening, defaults to 80.

.It http_server_fields_accept=HTTP FIELD[->ARRAY TAG][,...]
Specify a comma separated list POST and GET fields to allow from clients. Fields not specified here are ignored unless
.B http_server_fields_accept_any
is set to 'yes'.
An optional array tag may be specified for each field if the field name should be translated when added to the RRR array message.
This parameter is optional.

.It http_server_fields_accept_any={yes|no}
Accept any field names from incoming requests. May not be used with
.B http_server_fields_accept. 
Defaults to 'no'.

.It http_server_allow_empty_messages={yes|no}
Create RRR messages for incoming request even if no field names would be added to the message. Defaults to 'no'.

.It http_server_receive_full_request={yes|no}
Get HTTP data from the request and add it to an RRR array message along with any fields from POST and GET. 
The fields
.B http_method, http_endpoint, http_body, http_content_transfer_encoding
and
.B http_content_type
will be added. The latter two values will only be added if present in request header, and the body only if the request body has non-zero length.
These fields are always added regardless of other options, except from the
.B http_server_allow_empty_messages
option which need to be set to 'yes' for HTTP requests with zero length body to be processed.
Defaults to 'no'.

.It http_server_receive_raw_data={yes|no}
When receiving a request from a client, put the full request including header into an RRR message for other instances to pick up.

.It http_server_get_raw_response_from_senders={yes|no}
Instead of sending standard responses to clients, like "204 No Content", check senders of httpserver for raw data responses.
This option is useful in combination with
.B http_server_receive_raw_data
or
.B http_server_receive_full_request
as it is then possible for some other module to process the request and make a response.
The response message given back must have the topic
.B httpserver/raw/uuu
set. If a response is generated by another module based on an array message, the topic 'httpserver/request/uuu' must be changed
to 'httpserver/raw/uuu' for
.B httpserver
to pick it up.   
If httpserver receives messages which do not match any active requests, they are dropped after a timeout.

.It http_server_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional.
.El
.PP
With default configuration, having no parameters specified, no RRR messages will be generated for received requests.
.PP
Note that all incoming request have to use
.B HTTP/1.1
as protocol version, any other versions will be rejected.
.SS httpclient (PAI)
This module takes RRR messages from other modules and sends them to an HTTP server. Array values in received messages
may be sent as HTTP form fields. GET and POST are supported using either HTTP or HTTPS. This module does not
use any data sent from the server, any data received is ignored.
.PP
The following configuration parameters are available in the
.B httpclient
module:
.PP
.Bl -tag -width -indent
.It http_server=SERVER OR IP
Server to send data to, defaults to 'localhost'.
.B httpclient
will follow any redirects from the server, also to other servers. Redirects may be disabled.
  
.It http_endpoint=ENDPOINT
The endpoint to request from the server, e.g.
.B /index.php.
If the server responds with a redirect, this new endpoint will be used.
It is possible to specify a query string in the endpoint, like
.B /index.php?a=1&b=2.
If the server responds with redirect, this query string will not be included in the folling request.
If GET method is used, any query values from RRR messages will be appended to the query string, also if there are redirects.
.B httpclient
will detect whether a query string already exists in the URL and prefix the first parameter with either ? or &.
Defaults to
.B /.

.It http_transport_type={tls|plain|both}
If transport type is set to 'plain' or 'tls', HTTP or HTTPS will be
.B enforced,
which means that redirects fro the server to a different transport type than the chosen one will be rejected.
Use 'both' or leave unspecified for automatic transport type.

.It http_port=PORT
Port to use when connecting to the server. Defaults to 80 for HTTP and 443 for HTTPS. Redirects from the server to other
ports will override this value.

.It http_method={get|post_urlencoded|post_multipart}
Which method to use when sending data to the server. Defaults to
.B get.
.br
\(bu If
.B get
is used, any fields will be appended to the endpoint after a questionmark ?. GET requests have no body.
.br
\(bu If
.B post_urlencoded
is used, any fields will be made into a query string and sent in the POST body of type 'application/x-www-form-urlencoded'.
.br
\(bu If
.B post_multipart
is used, any fields will be made into separate mime parts and sent in the POST body of type 'multipart/form-data'. This method is recommended for large data fields.
 
.It http_tags=ARRAY TAG[->HTTP FIELD NAME][,...]
A comma separated list of array tags to find in RRR messages from other modules.
If left unspecified, all array values found will be sent to the HTTP server.
If a tag is postfixed with a
.B HTTP FIELD NAME,
this name instead of the array tag name when sending data to the HTTP server.
If tags are specified and an RRR message from a sender is missing one or more of the specified tags, and error is produced.
 
.It http_fields=HTTP FIELD NAME[=VALUE][,...]
A set of fixed fields to send to the HTTP server, optionally with values. Values from
.B http_fields
are always sent regardless of
.B http_tags.

.It http_rrr_msg_to_array={yes|no}
Convert fields in RRR messages from other modules to array values. The fields used are
.B timestamp, topic
and
.B data.
These values may be used in the same way as any other array values from the messages, they may also be matched in the
.B http_tags
parameter. If
.B http_tags
is specified, values from the RRR message will only be sent if they are specified here. Defaults to 'no'.

.It http_no_data={yes|no}
Ignore all data in RRR messages from other modules. Only query values in
.B http_endpoint
and
.B http_fields
, if specified, will be sent to the server. Defaults to 'no'.

.It http_drop_on_error={yes|no}
If there is any error while sending a message, drop it instead of deferring it and trying again later. Errors will be logged regardless of this setting. Defaults to 'no'.

.It http_message_timeout_ms=MILLISECONDS
Timeout for deferred messages, defaults to 0 which means no timeout.

.It http_max_redirects=UNSIGNED INTEGER
The maximum number of redirects to allow from the server for a single message. May be set to 0 to disallow redirects. Defaults to 5, maximum is 500.

.It http_keepalive={yes|no}
Keep connection to server open across multiple requests. When the server finally closes the connection, the client re-connects. Defaults to no.

.It http_receive_raw_data={yes|no}
Take the full response from the server and put it into an RRR message for other instances to pick up.
If the original message which caused the query had a topic set, this topic will be present in the message with the raw data.
May be used in conjunction with raw functionallity in
.B httpserver.

.It http_send_raw_data={yes|no}
Assume that received messages contains raw HTTP data (including headers), and send this to the specified server untouched.
May be used in conjunction with raw functionallity in
.B httpserver.

.It http_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional.
.El
.SS mqttbroker (N)
An MQTT broker supporting V3.1(.1) and V5.
.PP
The following configuration parameters are available in the
.B mqttbroker
module:
.PP
.Bl -tag -width -indent
.It mqtt_broker_port=PORT
TCP port to listen on (listens on all interfaces). Defaults to 1883.

.It mqtt_broker_port_tls=PORT
TCP port to listen on for TLS connections (listens on all interfaces). Defaults to 8883.

.It mqtt_broker_transport_type={plain|tls|both}
The transport type to use when listening. Defaults to 'plain'.

.It mqtt_broker_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional except from certificate file and private key.
.It mqtt_broker_max_keep_alive=SECONDS
Maximum keep-alive value for clients, defaults to 30.

.It mqtt_broker_retry_interval=SECONDS
Retry interval for QoS1 and QoS2 messages.

.It mqtt_broker_close_wait_time=SECONDS
After disconnect, wait this many seconds before closing the socket (make client close first to avoid TIME_WAIT). Defaults to 1 second.

.It mqtt_broker_v31_disconnect_on_publish_deny={yes|no}
If a V3.1 or V3.1.1 client sends a PUBLISH which is rejected by ACL rules, the client will be disconnected
if this option is set to yes. The default value is no, which means that the broker sends an acknowledgement packet
regardless of whether the PUBLISH was rejected or not. For V5, an acknowledgement with an error code is always sent,
disregarding this option.

.It mqtt_broker_password_file=FILENAME
Filename of an RRR password file created by
.Xr rrr_passwd(1)
with which users are authenticated. If left unspecified, all CONNECT packets containing a username will be rejected.
RRR does not allow CONNECT packets only containing usernames, a password must always be set.

.It mqtt_broker_permission_name=PERMISSION
The permission name to which a user must have been registered with by using
.Xr rrr_passwd(1)
to become authenticated with this broker. Defaults to
.B mqtt. 

.It mqtt_broker_require_authentication={yes|no}
Disallow anonymous logins. This defaults to 'yes' if a password file is set, otherwise it defaults to 'no'.

.It mqtt_broker_acl_file=FILENAME
ACL file to allow different users access to topics. If left unspecified, all access is granted. If a file is specified and a rule
is not found upon a PUBLISH or SUBSCRIBE from a client, access will be denied.
.PP
The ACL file consists of one or more
.B TOPIC {TOPIC STRING}
blocks. The
.B TOPIC STRING
value is an MQTT filter in which # and + are allowed according to the MQTT specifications. Curly brackets are not to be included.
.PP
A topic block may contain one or more lines beginning with one of the keywords
.B USER
or
.B DEFAULT
followed by one or more spaces or tabs. Keywords are case-insensitive.
.PP
The
.B DEFAULT
keyword takes one argument, an ACL action (DENY, READ or WRITE). If left unspecified, the default action is DENY.
.PP
The
.B USER
keyword takes two arguments, a username followed by one or more spaces or tabs and an ACL action (DENY, READ or WRITE).
.El
.PP
If
.B READ
access is granted, a user may SUBSCRIBE to the matching topics. If
.B WRITE
access is granted, a user may SUBSCRIBE and PUBLISH to the matching topics.
.B DENY
will block all access to the matching topics. 
.PP
The ACL file is parsed from top to bottom, and the bottom most matching rule will take precedence.
.PP
Comments may be placed on separate lines and begins with '#'. Spaces and tabs are allowed on the beginning of a line before keywords.
.PP
Below follows some example rules:
.PP
.nf
# BEGIN ACL FILE
# Allow access to everything from everyone
TOPIC #
	DEFAULT WRITE

# Allow only READ access on $SYS topics, but allow system_user to WRITE
TOPIC $SYS/#
	DEFAULT READ
	USER system_user WRITE
# END ACL FILE
.fi
.PP
The MQTT server follows the specifications from Oasis, but lacks support for the following (will be implemented shortly):
.PP
\(bu AUTH packet (simple username/password implemented)
.PP
.SS mqttclient (PA)
An MQTT client supporting V3.1.1 and V5. The client will publish RRR messages it receives from other modules, and
other modules can read messages the client receives on subscribed topics.
.PP
The following configuration parameters are available in the
.B mqttclient
module:
.PP
.Bl -tag -width -indent
.It mqtt_server=HOST
Host name or IP of the broker to connect to. Defaults to localhost.

.It mqtt_server_port=PORT
TCP port on the server for TLS connections, defaults to 1883 for plain transport and 8883 for TLS connection.

.It mqtt_transport_type={plain|tls}
The transport type to use when connecting to the server. Defaults to 'plain'.

.It mqtt_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional.

.It mqtt_client_identifier=IDENTIFIER
Client identifier to use. If left unspecified, the broker picks one.

.It mqtt_v5_recycle_assigned_client_identifier={yes|no}
If we let the broker pick a client identifier and we are using protocol version 5, the broker will inform the client
about which client identifier it assigned. If this option is set to yes and the client needs to re-connect for some reason,
it will attempt to use this assigned client identifier. In version 3, the broker does not inform the client about the
picked client identifier and this option is then ignored. Defaults to 'yes'.

.It mqtt_connect_error_action={restart|retry}
Default action if connecting to the server failed. If set to
.B restart,
all RRR modules will be restarted after a few connection attempts (might cause messages to be lost). If set to
.B retry,
the client will keep trying to connect without any restart (messages will not be lost). Default action is to restart.

.It mqtt_connect_attempts=NUMBER OF ATTEMPTS
How many times we attempt connecting to the broker before giving up.
What we do when this number is reached depends on the setting
.B mqtt_connect_error_action.
One connection attempt lasts approximately 100ms. Must be 1 or more, defaults to 20.

.It mqtt_discard_on_connect_retry={yes|no}
With this option set to 'yes' while
.B mqtt_connect_error_action
is 'retry' and a connect retry is performed, queued messages will be read from all senders and discarded. This might be needed
to avoid non-processed messages filling up memory in situations where the broker is not available for a longer period. If however
.B  mqtt_connect_error_action
is 'restart', all messages will be cleared anyway when all instances restart after mqttclient fails to connect.
.B mqtt_discard_on_connect_retry
may not be set to 'yes' in this situation. Defaults to 'no'.
  
.It mqtt_username=USERNAME
.It mqtt_password=PASSWORD
Optional username and password to send in CONNECT packets. If a password is set, a username
.B must
also be set. Note that the RRR MQTT broker disallows connects with username only, other brokers might handle this differently.

.It mqtt_qos={0|1|2}
Default Quality of Service to use, defaults to 1.

.It mqtt_version={3.1.1|5}
Default MQTT protocol version to use, defaults to 3.1.1.

.It mqtt_publish_topic=TOPIC
Topic to use when publishing RRR messages without topic set in them.
If left unspecified, RRR messages without a topic will be dropped.

.It mqtt_publish_topic_force={yes|no}
Force use of the topic specified in
.B mqtt_publish_topic
and disregard any topic in RRR messages. Cannot be used with
.B mqtt_publish_topic_prepend.
Defaults to no.

.It mqtt_publish_topic_prepend={yes|no}
The topic specified in
.B mqtt_publish_topic
is prepended to the topic RRR messages. No trailing or leading slashes are added. Cannot be used with
.B mqtt_publish_topic_force.
Messages without a topic are dropped if set to yes. Defaults to no.

.It mqtt_publish_rrr_message={yes|no}
If set to yes, the client will send full RRR messages.
If set to no, the raw data field of each RRR message will be sent, or a descriptive string with the message
type, class and timestamp is put into the publish payload for messages which do not have any data. Defaults to yes.

.It mqtt_publish_array_values={*|tag1[,tag2[,...]]}
Put all values from an array (*) or selected values (by tag) into the payload of PUBLISH messages. RRR
messages which does not contain an array are dropped. Any integer types will have big endianess in the resulting publish message.
Cannot be used with
.B mqtt_publish_rrr_message=yes.

.It mqtt_subscribe_topics=TOPIC1[,TOPIC2[,...]]
MQTT topic patterns to subscribe to (if any)

.It mqtt_receive_rrr_message={yes|no}
Expect to receive RRR messages from the broker.
If set to yes, any messages received which are not RRR messages are dropped.
If set to no and protocol version is V3.1.1, any data in messages received are put into a new RRR message.
If set to no and protocol version is V5, type of the received message is auto-detected.
Defaults to no.

.It mqtt_receive_array=ARRAY DEFINITION
If set, expect to receive data arrays of specific formats in publish messages.
This option cannot be used with mqtt_receive_rrr_message=yes, however if protocol version is V5,
received RRR messages will still be auto-detected, and array parsing will not occur for these.
Multiple data array records may reside in a single PUBLISH message, one RRR message will be generated for each record. 
Refer to
.Xr rrr_post(1)
for syntax of array definitions.
.El
.SS journal (SA)
Picks up RRR journal log messages and places them into arrays for other modules to read. Please note that this is not possible
to do with certain debuglevels active as passing messages generated by
.B journal
would cause generation of even more messages at an exponential growth rate.
.PP
RRR log messages from
.B journal
will have their MQTT topic set to
.B rrr/journal/{log_prefix}
where {log_prefix} (without curly brackets) is set by the originating module. It is not possible to change this topic,
but it may be changed in other modules which use these messages if required. See more details further down.
.PP
If a global debuglevel other than 1 is active, ...
.PP
\(bu all messages with a loglevel other 1 will be suppressed.
.br
\(bu messages from custom scripts which generate log messages (regardless of debuglevel) on other loglevels than 1 will be suppressed.
.br  
\(bu all log messages are still delivered to
.Xr rrr_stats(1)
and printed out (and delivered to syslog if RRR is an systemd daemon).
.PP
The following array tags can be retrieved from messages generated by
.B journal:
.PP
.Bl -tag -width -indent
.It log_level_translated
RFC 5424 loglevel, small integer.
.It log_prefix
The log prefix, usually path to the current RRR configuration file.
.It log_message
The actual log message (including syslog-syntax for loglevel and prefix)
.It log_hostname
The hostname of the current host or overridden hostname from configuration file.
.El
.PP
Messages generated while RRR is processing a signal are not delivered to
.B journal.
.PP
The following configuration parameters are available:
.PP
.Bl -tag -width -indent
.It journal_generate_test_messages={yes|no}
Generate dummy messages for testing purposes. Defaults to no.

.It journal_hostname=HOSTNAME
Hostname to send along with log messages. Defaults to system hostname.
.El

.SS file (SA)
Reads from files, character devices, block devices, sockets and FIFO pipes.
Full file contents may be read into RRR messages, or and array definition may be used to create RRR array messages from the data.
The
.B file
module periodically checks for new entries in the specified directory and tries to read from them.
.PP
Sockets, character devices and FIFO pipes are kept open until the other end closes them or EOF is encountered.
If disconnected,
.B
file
with attempt to reconnect with them in the next probe round unless they are deleted in the meantime.
FIFO pipes can be created with the
.Xr mkfifo(1)
command, and they can be written to easily with commands like
.B echo "blabla" > /tmp/rrr/my_rrr_fifo .
.PP
The
.B file
module can be used to manage a "drop" directory where other programs put files which are to be read into RRR.
When doing this, one must avoid that
.B file
tries to read files before they are completely written out.
This can be achieved by specifying a file prefix in the configuration and writing the files first with some temporary name
before finally, when writing is complete, renaming them to something matching the prefix.
.B file
may be configured to delete files after they are read.
.PP
There is no limit on how many files, sockets etc. which can be simultaneously open.
.PP
The following configuration parameters are available in the
.B file
module:
.PP
.Bl -tag -width -indent
.It file_directory=DIRECTORY
Directory in which to probe for files to read from. Must be set.

.It file_prefix=FILE PREFIX
Optional prefix for files to read from in the chosen directory. Non-matching files are ignored.

.It file_probe_interval_ms=MILLISECONDS
Probing for new files is done immediately after startup and then periodically every time the probe interval has passed.
A value of zero is allowed, this might be CPU intensive. Defaults to 5000 ms.

.It file_topic=MQTT TOPIC
Set an MQTT topic on generated messages. Optional parameter.

.It file_input_types=ARRAY DEFINITION
Parse array data from the entries found.
Reading will stop when there is an error or when EOF is encountered.
Cannot be used with
.B file_read_all_to_message=yes,
but one of them must be specified. No default value.

.It file_read_all_to_message={yes|no}
Read all data from the entries and put it into an RRR message.
Note that this is probably not useful for sockets and character devices. Cannot be used with
.B file_input_types,
but one of them must be specified. Defaults to 'no'.

.It file_unlink_on_close={yes|no}
After an open entry for any reason closes, attempt to unlink it. Note that
.B any type of file or socket will be deleted
as long as the user running RRR has permission to do that. Defaults to 'no'. 

.El
.SS mysql (DAI)
This module will read in messages from other modules, possibly IP-capable, and save them to a myqsl or MariaDB 
database.
.PP
A column plan must be used to describe the table we are saving to. The received data must match this column plan. If
the data saving for any reason fails, like if the database is down or the table is misconfigured, we cache the failed messages
and try again later. It is not possible for the mysql module to know wether it's settings are at fault or if the database
is at fault. Messages which fails can regardless of this be set to be dropped instead upon errors.
.PP
The following configuration parameters are available in the
.B mysql
module:
.PP
.Bl -tag -width -indent
.It mysql_server=SERVER NAME
The server name of the MySQL or MariaDB server to use

.It mysql_port=PORT NUMBER
The port number used to connect to the server.

.It mysql_user=USER NAME
The username for logging into the server

.It mysql_password=PASSWORD
The password for logging into the server

.It mysql_db=DATABASE NAME
The name of the database to use

.It mysql_table=TABLE NAME
The table name to use for storing data

.It mysql_drop_unknown_messages={yes|no}
If a message fails to be saved into the specified table for any reason, simply delete it instead of trying again later. Defaults to no.

.It mysql_columns={column name 1,column name 2,...}
Specify the columns in the table to write data to. The column count must match the number of values received in array
messages from other modules. The data types only matters to some extent, the columns should be able to hold the data
types received. Integers are sent to the database as integers and blobs are sent as blobs.
If an array contains items with more than one value, one column should be specified for the whole item. These items are always sent
to mysql as blobs.
This option cannot be used with
.B mysql_column_tags.

.It mysql_column_tags=ARRAY TAG[->MYSQL COLUMN][,...]
A comma separated list of items to retrieve from the received array messages and to use as
columns in MySQL. If a tag name is specified on is own, the tag and the corresponding column in MySQL has the same name.
If the MySQL column name is different from the tag, an arrow followed by the MySQL column name is put after the tag name.
This option cannot be used with
.B mysql_colums.

.It mysql_blob_write_columns={column name 1,column name 2,...}
Used to force to send data as blob (raw data) to the database for the specified columns regardless of their type.

.It mysql_special_columns={column1=value1,column2=value2,...}
Used to write fixed values to the database.

.It mysql_add_timestamp_col={yes|no}
In addition to the other columns, write to a column named `timestamp` and save the timestamp from the message here.

.It mysql_strip_array_separators={yes|no}
Disregard any separator items in received array messages. Defaults to yes.
.El
.SS influxdb (DA)
This module receives array messages from other modules and sends their data to an Influx database using HTTP.
.PP
The following configuration parameters are available in the
.B influxdb
module:
.PP
.Bl -tag -width -indent
.It influxdb_server=HOSTNAME
The IP address or hostname of the host running an Influxdb database.

.It influxdb_database=DATABASE
The database name to use on the server.

.It influxdb_table=TABLE
The table in the database in which to store the data.

.It influxdb_port=PORT
The port to use when connecting to the server, defaults to 8086.

.It influxdb_transport_type={plain|tls}
The transport type to use when connecting to the server. Defaults to 'plain'.

.It influxdb_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional.

.It influxdb_tags=ARRAY TAG[->INFLUXDB TAG][,...]
A comma separated list of items to retrieve from the received array messages and which should be used as
.B tags
in InfluxDB. If the tag of an
item in an array is not equal to the tag in InfluxDB, the tag may be followed by
.B ->INFLUXDB TAG
to translate the tag name. 
Items in an array message which are not tagged cannot be used.

.It influxdb_fields=ARRAY TAG[->INFLUXDB FIELD][,...]
A comma separated list of items to retrieve from the array and which are to be used as
.B fields
in InfluxDB. Otherwise same rules as for tags.

.It influxdb_fixed_tags=TAG[=VALUE][,...]
Optional comma separated list of fixed tags (and optionally with values) to save to InfluxDB.

.It influxdb_fixed_fields=FIELD[=VALUE][,...]
Optional comma separated list of fixed fields (and optionally with values) to save to InfluxDB.
.El
It is required to have at least one tag specified in either
.B influxdb_fields
or
.B influxdb_fixed_fields .
.SS voltmonitor (SA)
Read voltage readings from a USB device. For every reading, an array message is generated with the timestamp of the measurement
and the measurement itself as an unsigned 64-bit integer with the tag
.B measurement.
.PP
.Bl -tag -width -indent
.It vm_calibration=FLOAT
Factor to calibrate the readings, defaults to 1.124.

.It vm_channel={1|2}
Which channel to use on two-channel devices.

.It vm_message_topic=TOPIC
MQTT topic to apply to generated messages.
.El
.PP
.SS averager (PA)
The averager module reads point measurements from it's senders and produces average measurments over a given timespan and
at a given rate. Other messages are simply passed through.
.PP
The averager module expects to find the tag
.B measurement
in array messages from it's senders. It will generate average measurements with the following values as unsigned 64-bit integers:

.Bl -tag -width -indent
.It average
The average of the measurements received in the timespan.
.It max
The maximum value of all the measurements received in the timespan.
.It min
The minimum value of all the measurements received in the timespan.
.It timestamp_from
The lowest timestamp of all the measurements received in the timespan.
.It timestamp_to
The highest timestamp of all the measurements received in the timespan.
.El
.PP
The following configuration parameters are available in the
.B avarager
module:
.PP
.Bl -tag -width -indent
.It avg_timespan=SECONDS
How long timespan to average over. Defaults to 15 seconds.

.It avg_interval=SECONDS
How often to produce average calculations. Defaults to 10 seconds.

.It avg_preserve_points={yes|no}
Preserve individual measurements and put them in output buffer. Defaults to no.

.It avg_discard_unknowns={yes|no}
Delete messages which are not point measurements and information messages. Defaults to no, which means to simply forward them.

.It avg_message_topic=TOPIC
MQTT topic to apply to generated messages and any forwarded point messages.
.El
.SH COMMON CONFIGURATION PARAMETERS
Replace the
.B X
with the configuration paramenter prefix of the module.
.PP
.SS cmodule parameters
.Bl -tag -width -indent
.It X_source_interval_ms=MILLISECONDS
How many milliseconds to wait between each call of the source function. Defaults to 1000, one second.

.It X_sleep_time_ms=MILLISECONDS
How many milliseconds to sleep if nothing was processed in the worker after multiple processing loops.
Sleeping is performed to limit CPU usage.
It is possible to specify 0 which in practice creates a very small wait.
The worker will sleep once every round until something happens again. Defaults to 50ms.

.It X_nothing_happend_limit=UNSIGNED INTEGER
How many loops to perform in the worker with nothing being processed before starting to sleep.
Defaults to 250, must be 1 or greater.
 
.It X_log_prefix=PREFIX
Set a custom log prefix to be prepended to any log messages printed out. Use the RRR_MSG_x and RRR_DBG_x (x is a number)
macros to print messages like the reset of RRR does.

.It X_drop_on_error={yes|no}
If there is an error during processing of a message, just drop it instead of restarting the program.
Defaults to no.
.El
.SS TLS parameters
.Bl -tag -width -indent
.It X_tls_certificate_file=FILENAME
The certificate to use for TLS connections. Optional for clients, required for servers.

.It X_tls_key_file=FILENAME
The private key to use for TLS connections. Optional for clients, required for servers.

.It X_tls_ca_path=PATH[:OTHER_PATH...]
An alternative directory in which to search for CA certificates used when validating certificates. Debuglevel 1 will expose the actual search path. Optional.

.It X_tls_ca_file=FILENAME
A CA certificate file to use when validating certificates. Optional.
.El
.SH SEE ALSO
.Xr rrr(1),
.Xr rrr_post(1),
.Xr rrr_stats(1),
.Xr rrr_python3(5)
	
